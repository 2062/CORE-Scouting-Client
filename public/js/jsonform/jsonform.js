
/*
@fileoverview Core of the JSON Form client-side library.

Generates an HTML form from a structured data model and a layout description.

The library may also validate inputs entered by the user against the data model
upon form submission and create the structured data object initialized with the
values that were submitted.

The library depends on:
- jQuery
- the underscore library
- a JSON parser/serializer. Nothing to worry about in modern browsers.
- the JSONFormValidation library (in jsv.js) for validation purpose

See documentation at:
http://developer.joshfire.com/doc/dev/ref/jsonform

The library creates and maintains an internal data tree along with the DOM.
That structure is necessary to handle arrays (and nested arrays!) that are
dynamic by essence.
*/


(function() {

  (function(serverside, global, $, _, JSON) {
    /*
    	Regular expressions used to extract array indexes in input field names
    */

    var applyArrayPath, escapeHTML, escapeSelector, fieldTemplateSettings, fileDisplayTemplate, formNode, formTree, getInitialValue, getSchemaKey, initializeTabs, jsonform, reArray, reArraySingle, truncateToArrayDepth, valueTemplateSettings;
    reArray = /\[([0-9]*)\](?=\.|$)/g;
    reArraySingle = /\[([0-9]*)\](?:\.|$)/;
    /*
    	Template settings for form views
    */

    fieldTemplateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g
    };
    /*
    	Template settings for value replacement
    */

    valueTemplateSettings = {
      evaluate: /\{\[([\s\S]+?)\]\}/g,
      interpolate: /\{\{([\s\S]+?)\}\}/g
    };
    /*
    	The jsonform object whose methods will be exposed to the window object
    */

    jsonform = {
      util: {}
    };
    escapeHTML = function(string) {
      if (!string) {
        return "";
      }
      return ("" + string).replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
    };
    /*
    	Escapes selector name for use with jQuery
    	
    	All meta-characters listed in jQuery doc are escaped:
    	http://api.jquery.com/category/selectors/
    	
    	@function
    	@param {String} selector The jQuery selector to escape
    	@return {String} The escaped selector.
    */

    escapeSelector = function(selector) {
      return selector.replace(/([\!\"\#\$\%\&\'\(\)\*\+\,\.\/\:\;<\=\>\?\@\[\\\]\^\`\{\|\}\~])/g, "\\$1");
    };
    /*
    	Initializes tabular sections in forms. Such sections are generated by the
    	'selectfieldset' type of elements in JSON Form.
    	
    	Input fields that are not visible are automatically disabled
    	not to appear in the submitted form. That's on purpose, as tabs
    	are meant to convey an alternative (and not a sequence of steps).
    	
    	The tabs menu is not rendered as tabs but rather as a select field because
    	it's easier to grasp that it's an alternative.
    	
    	Code based on bootstrap-tabs.js, updated to:
    	- react to option selection instead of tab click
    	- disable input fields in non visible tabs
    	- disable the possibility to have dropdown menus (no meaning here)
    	- act as a regular function instead of as a jQuery plug-in.
    	
    	@function
    	@param {Object} tabs jQuery object that contains the tabular sections
    	to initialize. The object may reference more than one element.
    */

    initializeTabs = function(tabs) {
      var activate, enableFields, optionSelected, tabClicked;
      activate = function(element, container) {
        container.find("> .active").removeClass("active");
        return element.addClass("active");
      };
      enableFields = function($target, targetIndex) {
        $target.find("input, textarea, select").removeAttr("disabled");
        return $target.parent().children(":not([data-idx=" + targetIndex + "])").find("input, textarea, select").attr("disabled", "disabled");
      };
      optionSelected = function(e) {
        var $option, $select, $target, targetIdx;
        $option = $("option:selected", $(this));
        $select = $(this);
        targetIdx = $option.attr("data-idx") || $option.attr("value");
        $target = void 0;
        e.preventDefault();
        if ($option.hasClass("active")) {
          return;
        }
        $target = $(this).parents(".tabbable").eq(0).find(".tab-content [data-idx=" + targetIdx + "]");
        activate($option, $select);
        activate($target, $target.parent());
        return enableFields($target, targetIdx);
      };
      tabClicked = function(e) {
        var $a, $content, $target, targetIdx;
        $a = $("a", $(this));
        $content = $(this).parents(".tabbable").first().find(".tab-content").first();
        targetIdx = $(this).index();
        $target = $content.find("[data-idx=" + targetIdx + "]");
        e.preventDefault();
        activate($(this), $(this).parent());
        activate($target, $target.parent());
        if ($(this).parent().hasClass("jsonform-alternative")) {
          return enableFields($target, targetIdx);
        }
      };
      return tabs.each(function() {
        $(this).delegate("select.nav", "change", optionSelected);
        $(this).find("select.nav").each(function() {
          var $target, targetIdx;
          $(this).val($(this).find(".active").attr("value"));
          targetIdx = $(this).find("option:selected").attr("data-idx") || $(this).find("option:selected").attr("value");
          $target = $(this).parents(".tabbable").eq(0).find(".tab-content [data-idx=" + targetIdx + "]");
          return enableFields($target, targetIdx);
        });
        $(this).delegate("ul.nav li", "click", tabClicked);
        return $(this).find("ul.nav li.active").click();
      });
    };
    jsonform.fieldTemplate = function(inner) {
      return "<div class=\"control-group jsonform-error-<%= keydash %> <%= elt.htmlClass ? elt.htmlClass : \"\" %>\"><% if (node.title && !elt.notitle) { %><label class=\"control-label\" for=\"<%= node.id %>\"><%= node.title %></label><% } %><div class=\"controls\"><% if (node.prepend || node.append) { %><div class=\"<% if (node.prepend) { %>input-prepend<% } %><% if (node.append) { %> input-append<% } %>\"><% if (node.prepend) { %><span class=\"add-on\"><%= node.prepend %></span><% } %><% } %>" + inner + "<% if (node.append) { %><span class=\"add-on\"><%= node.append %></span><% } %><% if (node.prepend || node.append) { %></div><% } %><% if (node.description) { %><span class=\"help-inline\"><%= node.description %></span><% } %><span class=\"help-block jsonform-errortext\" style=\"display:none;\"></span></div></div>";
    };
    fileDisplayTemplate = "<% if (value.type==\"image\") { %><img class=\"jsonform-preview\" id=\"jsonformpreview-<%= id %>\" src=\"<%= value.url %>\" /><% } else { %><a href=\"<%= value.url %>\"><%= value.name %></a> (<%= Math.ceil(value.size/1024) %>kB)<% } %><br/>";
    jsonform.elementTypes = {
      none: {
        template: ""
      },
      root: {
        template: "<div><%= children %></div>"
      },
      text: {
        template: "<input class=\"input-xlarge xlarge\" type=\"text\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"<%= (node.disabled? \" disabled\" : \"\")%> />",
        fieldtemplate: true,
        inputfield: true
      },
      password: {
        template: "<input class=\"input-xlarge xlarge\" type=\"password\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"<%= (node.disabled? \" disabled\" : \"\")%> />",
        fieldtemplate: true,
        inputfield: true
      },
      color: {
        template: "<input class=\"input-xlarge xlarge\" type=\"text\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"<%= (node.disabled? \" disabled\" : \"\")%> />",
        fieldtemplate: true,
        inputfield: true,
        onInsert: function(evt, node) {
          return $(node.el).find("#" + escapeSelector(node.id)).spectrum({
            preferredFormat: "hex",
            showInput: true
          });
        }
      },
      textarea: {
        template: "<textarea id=\"<%= id %>\" name=\"<%= node.name %>\" style=\"height:<%= elt.height || \"150px\" %>;width:<%= elt.width || \"100%\" %>;\"<%= (node.disabled? \" disabled\" : \"\")%>><%= value %></textarea>",
        fieldtemplate: true,
        inputfield: true
      },
      wysihtml5: {
        template: "<textarea id=\"<%= id %>\" name=\"<%= node.name %>\" style=\"height:<%= elt.height || \"300px\" %>;width:<%= elt.width || \"100%\" %>;\"><%= value %></textarea>",
        fieldtemplate: true,
        inputfield: true,
        onInsert: function(evt, node) {
          var itv, setup;
          setup = function() {
            if ($(node.el).data("wysihtml5")) {
              return;
            }
            $(node.el).data("wysihtml5_loaded", true);
            return $(node.el).find("#" + escapeSelector(node.id)).wysihtml5({
              html: true,
              link: true,
              "font-styles": true,
              image: true
            });
          };
          if (window.jsonform_wysihtml5_setup) {
            window.jsonform_wysihtml5_setup(setup);
            return;
          }
          return itv = window.setInterval(function() {
            if (window.wysihtml5) {
              window.clearInterval(itv);
              return setup();
            }
          }, 1000);
        }
      },
      ace: {
        template: "<div id=\"<%= id %>\" style=\"position:relative;height:<%= elt.height || \"300px\" %>;\"><div id=\"<%= id %>__ace\" style=\"width:<%= elt.width || \"100%\" %>;height:<%= elt.height || \"300px\" %>;\"></div><input type=\"hidden\" name=\"<%= node.name %>\" id=\"<%= id %>__hidden\" value=\"<%= escape(value) %>\"/></div>",
        fieldtemplate: true,
        inputfield: true,
        onInsert: function(evt, node) {
          var itv, setup;
          setup = function() {
            var ace, editor, formElement, idSelector, lazyChanged, mode;
            formElement = node.formElement || {};
            ace = window.ace;
            editor = ace.edit($(node.el).find("#" + escapeSelector(node.id) + "__ace").get(0));
            idSelector = "#" + escapeSelector(node.id) + "__hidden";
            editor.getSession().setNewLineMode("unix");
            editor.renderer.setShowPrintMargin(false);
            editor.setTheme("ace/theme/" + (formElement.aceTheme || "twilight"));
            if (formElement.aceMode) {
              mode = ace.require("ace/mode/" + formElement.aceMode).Mode;
              editor.getSession().setMode(new mode());
            }
            editor.getSession().setTabSize(2);
            editor.getSession().setValue(node.value || "");
            lazyChanged = _.debounce(function() {
              $(node.el).find(idSelector).val(editor.getSession().getValue());
              return $(node.el).find(idSelector).change();
            }, 600);
            editor.getSession().on("change", lazyChanged);
            editor.on("blur", function() {
              $(node.el).find(idSelector).change();
              return $(node.el).find(idSelector).trigger("blur");
            });
            return editor.on("focus", function() {
              return $(node.el).find(idSelector).trigger("focus");
            });
          };
          if (window.jsonform_ace_setup) {
            window.jsonform_ace_setup(setup);
            return;
          }
          return itv = window.setInterval(function() {
            if (window.ace) {
              window.clearInterval(itv);
              return setup();
            }
          }, 1000);
        }
      },
      checkbox: {
        template: "<label class=\"checkbox\"><input type=\"checkbox\" id=\"<%= id %>\" name=\"<%= node.name %>\" value=\"1\" <% if (value) {%>checked<% } %><%= (node.disabled? \" disabled\" : \"\")%> /><span><%= node.inlinetitle || \"\" %></span></label>",
        fieldtemplate: true,
        inputfield: true,
        getElement: function(el) {
          return $(el).parent().get(0);
        }
      },
      file: {
        template: "<input class=\"input-file\" id=\"<%= id %>\" name=\"<%= node.name %>\" type=\"file\" />",
        fieldtemplate: true,
        inputfield: true
      },
      "file-hosted-public": {
        template: "<span><% if (value && (value.type||value.url)) { %>" + fileDisplayTemplate + "<% } %><input class=\"input-file\" id=\"_transloadit_<%= id %>\" type=\"file\" name=\"<%= transloaditname %>\" /><input data-transloadit-name=\"_transloadit_<%= transloaditname %>\" type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value='<%= escape(JSON.stringify(node.value)) %>' /></span>",
        fieldtemplate: true,
        inputfield: true,
        getElement: function(el) {
          return $(el).parent().get(0);
        },
        onBeforeRender: function(data, node) {
          if (!node.ownerTree._transloadit_generic_public_index) {
            node.ownerTree._transloadit_generic_public_index = 1;
          } else {
            node.ownerTree._transloadit_generic_public_index++;
          }
          data.transloaditname = "_transloadit_jsonform_genericupload_public_" + node.ownerTree._transloadit_generic_public_index;
          if (!node.ownerTree._transloadit_generic_elts) {
            node.ownerTree._transloadit_generic_elts = {};
          }
          return node.ownerTree._transloadit_generic_elts[data.transloaditname] = node;
        },
        onChange: function(evt, elt) {
          var formElt;
          if (elt.ownerTree._transloadit_bound) {
            return false;
          }
          elt.ownerTree._transloadit_bound = true;
          formElt = $(elt.ownerTree.domRoot);
          return formElt.transloadit({
            autoSubmit: false,
            wait: true,
            onSuccess: function(assembly) {
              var f, i;
              if (assembly.results[":original"]) {
                i = 0;
                while (i < assembly.results[":original"].length) {
                  f = assembly.results[":original"][i];
                  $("#" + escapeSelector(elt.ownerTree._transloadit_generic_elts[f.field].id), formElt).val(JSON.stringify(f));
                  i++;
                }
              }
              elt.ownerTree._transloadit_bound = false;
              formElt.unbind("submit.transloadit");
              return setTimeout((function() {
                return elt.ownerTree.submit();
              }), 10);
            },
            onError: function(assembly) {
              return console.log("Assembly error", assembly);
            }
          });
        },
        onSubmit: function(evt, elt) {
          if (elt.ownerTree._transloadit_bound) {
            return false;
          }
          return true;
        }
      },
      "file-transloadit": {
        template: "<span><% if (value && (value.type||value.url)) { %>" + fileDisplayTemplate + "<% } %><input class=\"input-file\" id=\"_transloadit_<%= id %>\" type=\"file\" name=\"_transloadit_<%= node.name %>\" /><input type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value='<%= escape(JSON.stringify(node.value)) %>' /></span>",
        fieldtemplate: true,
        inputfield: true,
        getElement: function(el) {
          return $(el).parent().get(0);
        },
        onChange: function(evt, elt) {
          var formElt;
          if (elt.ownerTree._transloadit_bound) {
            return false;
          }
          elt.ownerTree._transloadit_bound = true;
          formElt = $(elt.ownerTree.domRoot);
          return formElt.transloadit({
            autoSubmit: false,
            wait: true,
            onSuccess: function(assembly) {
              var f, i;
              if (assembly.results[":original"]) {
                i = 0;
                while (i < assembly.results[":original"].length) {
                  f = assembly.results[":original"][i];
                  $("input[name='" + f.field.replace(/^_transloadit_/, "") + "']", formElt).val(JSON.stringify(f));
                  i++;
                }
              }
              elt.ownerTree._transloadit_bound = false;
              formElt.unbind("submit.transloadit");
              return setTimeout((function() {
                return elt.ownerTree.submit();
              }), 10);
            },
            onError: function(assembly) {
              return console.log("Assembly error", assembly);
            }
          });
        },
        onSubmit: function(evt, elt) {
          if (elt.ownerTree._transloadit_bound) {
            return false;
          }
          return true;
        }
      },
      select: {
        template: "<select name=\"<%= node.name %>\" id=\"<%= id %>\" <%= (node.disabled? \" disabled\" : \"\")%>> <% _.each(node.options, function(key, val) { if(key instanceof Object) { if (value === key.value) { %> <option selected value=\"<%= key.value %>\"><%= key.title %></option> <% } else { %> <option value=\"<%= key.value %>\"><%= key.title %></option> <% }} else { if (value === key) { %> <option selected value=\"<%= key %>\"><%= key %></option> <% } else { %><option value=\"<%= key %>\"><%= key %></option> <% }}}); %> </select>",
        fieldtemplate: true,
        inputfield: true
      },
      imageselect: {
        template: "<div><input type=\"hidden\" name=\"<%= node.name %>\" id=\"<%= node.id %>\" value=\"<%= value %>\" /><div class=\"dropdown\"><a class=\"btn<% if (buttonClass && node.value) { %> <%= buttonClass %><% } %>\" data-toggle=\"dropdown\" href=\"#\"<% if (node.value) { %> style=\"max-width:<%= width %>px;max-height:<%= height %>px\"<% } %>><% if (node.value) { %><img src=\"<% if (!node.value.match(/^https?:/)) { %><%= prefix %><% } %><%= node.value %><%= suffix %>\" alt=\"\" /><% } else { %><%= buttonTitle %><% } %></a><div class=\"dropdown-menu navbar\" id=\"<%= node.id %>_dropdown\"><div><% _.each(node.options, function(key, idx) { if ((idx > 0) && ((idx % columns) === 0)) { %></div><div><% } %><a class=\"btn<% if (buttonClass) { %> <%= buttonClass %><% } %>\" style=\"max-width:<%= width %>px;max-height:<%= height %>px\"><% if (key instanceof Object) { %><img src=\"<% if (!key.value.match(/^https?:/)) { %><%= prefix %><% } %><%= key.value %><%= suffix %>\" alt=\"<%= key.title %>\" /></a><% } else { %><img src=\"<% if (!key.match(/^https?:/)) { %><%= prefix %><% } %><%= key %><%= suffix %>\" alt=\"\" /><% } %></a> <% }); %></div><div class=\"pagination-right\"><a class=\"btn\">Reset</a></div></div></div></div>",
        fieldtemplate: true,
        inputfield: true,
        onBeforeRender: function(data, node) {
          var elt, maxColumns, nbRows;
          elt = node.formElement || {};
          nbRows = null;
          maxColumns = elt.imageSelectorColumns || 5;
          data.buttonTitle = elt.imageSelectorTitle || "Select...";
          data.prefix = elt.imagePrefix || "";
          data.suffix = elt.imageSuffix || "";
          data.width = elt.imageWidth || 32;
          data.height = elt.imageHeight || 32;
          data.buttonClass = elt.imageButtonClass || false;
          if (node.options.length > maxColumns) {
            nbRows = Math.ceil(node.options.length / maxColumns);
            return data.columns = Math.ceil(node.options.length / nbRows);
          } else {
            return data.columns = maxColumns;
          }
        },
        getElement: function(el) {
          return $(el).parent().get(0);
        },
        onInsert: function(evt, node) {
          return $(node.el).on("click", ".dropdown-menu a", function(evt) {
            var elt, height, img, prefix, suffix, value, width;
            evt.preventDefault();
            evt.stopPropagation();
            img = (evt.target.nodeName.toLowerCase() === "img" ? $(evt.target) : $(evt.target).find("img"));
            value = img.attr("src");
            elt = node.formElement || {};
            prefix = elt.imagePrefix || "";
            suffix = elt.imageSuffix || "";
            width = elt.imageWidth || 32;
            height = elt.imageHeight || 32;
            if (value) {
              if (value.indexOf(prefix) === 0) {
                value = value.substring(prefix.length);
              }
              value = value.substring(0, value.length - suffix.length);
              $(node.el).find("input").attr("value", value);
              return $(node.el).find("a[data-toggle=\"dropdown\"]").addClass(elt.imageButtonClass).attr("style", "max-width:" + width + "px;max-height:" + height + "px").html("<img src=\"" + (!value.match(/^https?:/) ? prefix : "") + value + suffix + "\" alt=\"\" />");
            } else {
              $(node.el).find("input").attr("value", "");
              return $(node.el).find("a[data-toggle=\"dropdown\"]").removeClass(elt.imageButtonClass).removeAttr("style").html(elt.imageSelectorTitle || "Select...");
            }
          });
        }
      },
      radios: {
        template: "<div id=\"<%= node.id %>\"><% _.each(node.options, function(key, val) { %><label class=\"radio\"><input type=\"radio\" <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked=\"checked\" <% } %> name=\"<%= node.name %>\" value=\"<%= (key instanceof Object ? key.value : key) %>\"<%= (node.disabled? \" disabled\" : \"\")%>/><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>",
        fieldtemplate: true,
        inputfield: true
      },
      radiobuttons: {
        template: "<div id=\"<%= node.id %>\"><% _.each(node.options, function(key, val) { %><label class=\"radio btn\"><input type=\"radio\" style=\"position:absolute;left:-9999px;\" <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked=\"checked\" <% } %> name=\"<%= node.name %>\" value=\"<%= (key instanceof Object ? key.value : key) %>\" /><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>",
        fieldtempate: true,
        inputfield: true,
        onInsert: function(evt, node) {
          var activeClass, elt;
          activeClass = "active";
          elt = node.formElement || {};
          if (elt.activeClass) {
            activeClass += " " + elt.activeClass;
          }
          return $(node.el).find("label").on("click", function() {
            $(this).parent().find("label").removeClass(activeClass);
            return $(this).addClass(activeClass);
          });
        }
      },
      checkboxes: {
        template: "<div><%= choiceshtml %></div>",
        fieldtemplate: true,
        inputfield: true,
        onBeforeRender: function(data, node) {
          var choices, choiceshtml, template;
          choices = null;
          choiceshtml = null;
          template = "<label class=\"checkbox\"><input type=\"checkbox\" <% if (value) { %> checked=\"checked\" <% } %> name=\"<%= name %>\" value=\"1\"<%= (node.disabled? \" disabled\" : \"\")%>><span><%= title %></span></label>";
          if (!node || !node.schemaElement || !node.schemaElement.items) {
            return;
          }
          choices = node.schemaElement.items["enum"] || node.schemaElement.items[0]["enum"];
          if (!choices) {
            return;
          }
          choiceshtml = "";
          _.each(choices, function(choice, idx) {
            return choiceshtml += _.template(template, {
              name: node.key + "[" + idx + "]",
              value: _.include(node.value, choice),
              title: (node.formElement.titleMap ? node.formElement.titleMap[choice] : choice),
              node: node
            }, fieldTemplateSettings);
          });
          return data.choiceshtml = choiceshtml;
        }
      },
      array: {
        template: "<div id=\"<%= id %>\"><ul class=\"_jsonform-array-ul\" style=\"list-style-type:none;\"><%= children %></ul><span class=\"_jsonform-array-buttons\"><a href=\"#\" class=\"btn _jsonform-array-addmore\"><i class=\"icon-plus-sign\" title=\"Add new\"></i></a> <a href=\"#\" class=\"btn _jsonform-array-deletelast\"><i class=\"icon-minus-sign\" title=\"Delete last\"></i></a></span></div>",
        fieldtemplate: true,
        array: true,
        childTemplate: function(inner) {
          if ($("").sortable) {
            return "<li data-idx=\"<%= node.childPos %>\"><span class=\"draggable line\"><i class=\"icon-list\" title=\"Move item\"></i></span>" + inner + "</li>";
          } else {
            return "<li data-idx=\"<%= node.childPos %>\">" + inner + "</li>";
          }
        },
        onInsert: function(evt, node) {
          var $nodeid, boundaries, curItems, i, moveNodeTo;
          $nodeid = $(node.el).find("#" + escapeSelector(node.id));
          boundaries = node.getArrayBoundaries();
          moveNodeTo = function(fromIdx, toIdx) {
            var fromEl, i, incr, parentEl, toEl;
            if (fromIdx === toIdx) {
              return;
            }
            incr = (fromIdx < toIdx ? 1 : -1);
            i = 0;
            parentEl = $("> ul", $nodeid);
            i = fromIdx;
            while (i !== toIdx) {
              node.children[i].switchValuesWith(node.children[i + incr]);
              node.children[i].render(parentEl.get(0));
              node.children[i + incr].render(parentEl.get(0));
              i += incr;
            }
            fromEl = $(node.children[fromIdx].el);
            toEl = $(node.children[toIdx].el);
            fromEl.detach();
            toEl.detach();
            if (fromIdx < toIdx) {
              if (fromIdx === 0) {
                parentEl.prepend(fromEl);
              } else {
                $(node.children[fromIdx - 1].el).after(fromEl);
              }
              return $(node.children[toIdx - 1].el).after(toEl);
            } else {
              if (toIdx === 0) {
                parentEl.prepend(toEl);
              } else {
                $(node.children[toIdx - 1].el).after(toEl);
              }
              return $(node.children[fromIdx - 1].el).after(fromEl);
            }
          };
          $("> span > a._jsonform-array-addmore", $nodeid).click(function(evt) {
            var idx;
            evt.preventDefault();
            evt.stopPropagation();
            idx = node.children.length;
            if (boundaries.maxItems >= 0) {
              if (node.children.length > boundaries.maxItems - 2) {
                $("> span > a._jsonform-array-addmore", $nodeid).addClass("disabled");
              }
              if (node.children.length > boundaries.maxItems - 1) {
                return false;
              }
            }
            node.insertArrayItem(idx, $("> ul", $nodeid).get(0));
            if (boundaries.minItems > 0 && node.children.length > boundaries.minItems - 1) {
              return $("> span > a._jsonform-array-deletelast", $nodeid).removeClass("disabled");
            }
          });
          curItems = $("> ul > li", $nodeid).length;
          if (boundaries.minItems >= 0 && curItems < boundaries.minItems) {
            i = 0;
            while (i < (boundaries.minItems - 1) && ($("> ul > li", $nodeid).length < boundaries.minItems)) {
              node.insertArrayItem(curItems, $("> ul", $nodeid).get(0));
              i++;
            }
            $("> span > a._jsonform-array-deletelast", $nodeid).addClass("disabled");
          }
          $("> span > a._jsonform-array-deletelast", $nodeid).click(function(evt) {
            var idx;
            idx = node.children.length - 1;
            evt.preventDefault();
            evt.stopPropagation();
            if (boundaries.minItems > 0) {
              if (node.children.length < boundaries.minItems + 2) {
                $("> span > a._jsonform-array-deletelast", $nodeid).addClass("disabled");
              }
              if (node.children.length <= boundaries.minItems) {
                return false;
              }
            }
            node.deleteArrayItem(idx);
            if (boundaries.maxItems >= 0 && idx <= boundaries.maxItems - 1) {
              return $("> span > a._jsonform-array-addmore", $nodeid).removeClass("disabled");
            }
          });
          if ($(node.el).sortable) {
            $("> ul", $nodeid).sortable();
            return $("> ul", $nodeid).bind("sortstop", function(event, ui) {
              var idx, newIdx;
              idx = $(ui.item).data("idx");
              newIdx = $(ui.item).index();
              return moveNodeTo(idx, newIdx);
            });
          }
        }
      },
      tabarray: {
        template: "<div id=\"<%= id %>\"><div class=\"tabbable tabs-left\"><ul class=\"nav nav-tabs\"><%= tabs %></ul><div class=\"tab-content\"><%= children %></div></div><a href=\"#\" class=\"btn _jsonform-array-addmore\"><i class=\"icon-plus-sign\" title=\"Add new\"></i></a> <a href=\"#\" class=\"btn _jsonform-array-deleteitem\"><i class=\"icon-minus-sign\" title=\"Delete item\"></i></a></div>",
        fieldtemplate: true,
        array: true,
        childTemplate: function(inner) {
          return "<div data-idx=\"<%= node.childPos %>\" class=\"tab-pane\">" + inner + "</div>";
        },
        onBeforeRender: function(data, node) {
          var tabs;
          tabs = "";
          _.each(node.children, function(child, idx) {
            var title;
            title = child.legend || child.title || ("Item " + (idx + 1));
            return tabs += "<li data-idx=\"" + idx + "\"" + (idx === 0 ? " class=\"active\"" : "") + "><a class=\"draggable tab\" data-toggle=\"tab\">" + escapeHTML(title) + "</a></li>";
          });
          return data.tabs = tabs;
        },
        onInsert: function(evt, node) {
          var $nodeid, boundaries, i, moveNodeTo, updateTabs;
          $nodeid = $(node.el).find("#" + escapeSelector(node.id));
          boundaries = node.getArrayBoundaries();
          moveNodeTo = function(fromIdx, toIdx) {
            var i, incr, tabEl, _results;
            if (fromIdx === toIdx) {
              return;
            }
            incr = (fromIdx < toIdx ? 1 : -1);
            i = 0;
            tabEl = $("> .tabbable > .tab-content", $nodeid).get(0);
            i = fromIdx;
            _results = [];
            while (i !== toIdx) {
              node.children[i].switchValuesWith(node.children[i + incr]);
              node.children[i].render(tabEl);
              node.children[i + incr].render(tabEl);
              _results.push(i += incr);
            }
            return _results;
          };
          updateTabs = function(selIdx) {
            var activateFirstTab, tabs;
            tabs = "";
            activateFirstTab = false;
            if (selIdx === undefined) {
              selIdx = $("> .tabbable > .nav-tabs .active", $nodeid).data("idx");
              if (selIdx) {
                selIdx = parseInt(selIdx, 10);
              } else {
                activateFirstTab = true;
                selIdx = 0;
              }
            }
            if (selIdx >= node.children.length) {
              selIdx = node.children.length - 1;
            }
            _.each(node.children, function(child, idx) {
              var title;
              title = child.legend || child.title || ("Item " + (idx + 1));
              return tabs += "<li data-idx=\"" + idx + "\"><a class=\"draggable tab\" data-toggle=\"tab\">" + escapeHTML(title) + "</a></li>";
            });
            $("> .tabbable > .nav-tabs", $nodeid).html(tabs);
            if (activateFirstTab) {
              $("> .tabbable > .nav-tabs [data-idx=\"0\"]", $nodeid).addClass("active");
            }
            return $("> .tabbable > .nav-tabs [data-toggle=\"tab\"]", $nodeid).eq(selIdx).click();
          };
          $("> a._jsonform-array-deleteitem", $nodeid).click(function(evt) {
            var idx;
            idx = $("> .tabbable > .nav-tabs .active", $nodeid).data("idx");
            evt.preventDefault();
            evt.stopPropagation();
            if (boundaries.minItems > 0) {
              if (node.children.length < boundaries.minItems + 1) {
                $("> a._jsonform-array-deleteitem", $nodeid).addClass("disabled");
              }
              if (node.children.length < boundaries.minItems) {
                return false;
              }
            }
            node.deleteArrayItem(idx);
            updateTabs();
            if (node.children.length < boundaries.minItems + 1) {
              $("> a._jsonform-array-deleteitem", $nodeid).addClass("disabled");
            }
            if (boundaries.maxItems >= 0 && node.children.length <= boundaries.maxItems) {
              return $("> a._jsonform-array-addmore", $nodeid).removeClass("disabled");
            }
          });
          $("> a._jsonform-array-addmore", $nodeid).click(function(evt) {
            var idx;
            idx = node.children.length;
            if (boundaries.maxItems >= 0) {
              if (node.children.length > boundaries.maxItems - 2) {
                $("> a._jsonform-array-addmore", $nodeid).addClass("disabled");
              }
              if (node.children.length > boundaries.maxItems - 1) {
                return false;
              }
            }
            evt.preventDefault();
            evt.stopPropagation();
            node.insertArrayItem(idx, $("> .tabbable > .tab-content", $nodeid).get(0));
            updateTabs(idx);
            if (boundaries.minItems > 0 && idx > boundaries.minItems - 1) {
              return $("> a._jsonform-array-deleteitem", $nodeid).removeClass("disabled");
            }
          });
          $(node.el).on("legendUpdated", function(evt) {
            updateTabs();
            evt.preventDefault();
            return evt.stopPropagation();
          });
          if ($(node.el).sortable) {
            $("> .tabbable > .nav-tabs", $nodeid).sortable({
              containment: node.el,
              tolerance: "pointer"
            });
            $("> .tabbable > .nav-tabs", $nodeid).bind("sortstop", function(event, ui) {
              var idx, newIdx;
              idx = $(ui.item).data("idx");
              newIdx = $(ui.item).index();
              moveNodeTo(idx, newIdx);
              return updateTabs(newIdx);
            });
          }
          if (boundaries.minItems >= 0) {
            i = 0;
            while (i < (boundaries.minItems - 1)) {
              $("> a._jsonform-array-addmore", $nodeid).click();
              i++;
            }
            $("> a._jsonform-array-deleteitem", $nodeid).addClass("disabled");
            updateTabs();
          }
          if ((boundaries.maxItems >= 0) && (node.children.length >= boundaries.maxItems)) {
            $("> a._jsonform-array-addmore", $nodeid).addClass("disabled");
          }
          if ((boundaries.minItems >= 0) && (node.children.length <= boundaries.minItems)) {
            return $("> a._jsonform-array-deleteitem", $nodeid).addClass("disabled");
          }
        }
      },
      help: {
        template: "<span class=\"help-block\" style=\"padding-top:5px\"><%= elt.helpvalue %></span>",
        fieldtemplate: true
      },
      msg: {
        template: "<%= elt.msg %>"
      },
      fieldset: {
        template: "<fieldset class=\"control-group jsonform-error-<%= keydash %> <% if (elt.expandable) { %>expandable<% } %> <%= elt.htmlClass?elt.htmlClass:\"\" %>\" <% if (id) { %> id=\"<%= id %>\"<% } %>><% if (node.title || node.legend) { %><legend><%= node.title || node.legend %></legend><% } %><% if (elt.expandable) { %><div class=\"control-group\"><% } %><%= children %><% if (elt.expandable) { %></div><% } %></fieldset>"
      },
      advancedfieldset: {
        template: "<fieldset<% if (id) { %> id=\"<%= id %>\"<% } %> class=\"expandable <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><legend>Advanced options</legend><div class=\"control-group\"><%= children %></div></fieldset>"
      },
      authfieldset: {
        template: "<fieldset<% if (id) { %> id=\"<%= id %>\"<% } %> class=\"expandable <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><legend>Authentication settings</legend><div class=\"control-group\"><%= children %></div></fieldset>"
      },
      submit: {
        template: "<input type=\"submit\" <% if (id) { %> id=\"<%= id %>\" <% } %> class=\"btn btn-primary <%= elt.htmlClass?elt.htmlClass:\"\" %>\" value=\"<%= value || node.title %>\"<%= (node.disabled? \" disabled\" : \"\")%>/>"
      },
      button: {
        template: " <button <% if (id) { %> id=\"<%= id %>\" <% } %> class=\"btn <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><%= node.title %></button> "
      },
      actions: {
        template: "<div class=\"form-actions <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><%= children %></div>"
      },
      hidden: {
        template: "<input type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" />",
        inputfield: true
      },
      selectfieldset: {
        template: "<fieldset class=\"tab-container <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><% if (node.legend) { %><legend><%= node.legend %></legend><% } %><% if (node.formElement.key) { %><input type=\"hidden\" id=\"<%= node.id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" /><% } else { %><a id=\"<%= node.id %>\"></a><% } %><div class=\"tabbable\"><div class=\"control-group<%= node.formElement.hideMenu ? \" hide\" : \"\" %>\"><% if (node.title && !elt.notitle) { %><label class=\"control-label\" for=\"<%= node.id %>\"><%= node.title %></label><% } %><div class=\"controls\"><%= tabs %></div></div><div class=\"tab-content\"><%= children %></div></div></fieldset>",
        inputfield: true,
        getElement: function(el) {
          return $(el).parent().get(0);
        },
        childTemplate: function(inner) {
          return "<div data-idx=\"<%= node.childPos %>\" class=\"tab-pane<% if (node.active) { %> active<% } %>\">" + inner + "</div>";
        },
        onBeforeRender: function(data, node) {
          var activeChild, children, choices, elt, tabs;
          children = null;
          choices = [];
          if (node.schemaElement) {
            choices = node.schemaElement["enum"] || [];
          }
          if (node.options) {
            children = _.map(node.options, function(option, idx) {
              var child;
              child = node.children[idx];
              if (option instanceof Object) {
                option = _.extend({
                  node: child
                }, option);
                option.title = option.title || child.legend || child.title || ("Option " + (child.childPos + 1));
                option.value = option.value || choices[idx] || idx;
                return option;
              } else {
                return {
                  title: option,
                  value: choices[child.childPos] || child.childPos,
                  node: child
                };
              }
            });
          } else {
            children = _.map(node.children, function(child, idx) {
              return {
                title: child.legend || child.title || ("Option " + (child.childPos + 1)),
                value: choices[child.childPos] || child.childPos,
                node: child
              };
            });
          }
          activeChild = null;
          if (data.value) {
            activeChild = _.find(children, function(child) {
              return child.value === node.value;
            });
          }
          if (!activeChild) {
            activeChild = _.find(children, function(child) {
              return child.node.hasNonDefaultValue();
            });
          }
          if (!activeChild) {
            activeChild = children[0];
          }
          activeChild.node.active = true;
          data.value = activeChild.value;
          elt = node.formElement;
          tabs = "<select class=\"nav\"" + (node.disabled ? " disabled" : "") + ">";
          _.each(children, function(child, idx) {
            return tabs += "<option data-idx=\"" + idx + "\" value=\"" + child.value + "\"" + (child.node.active ? " class=\"active\"" : "") + ">" + escapeHTML(child.title) + "</option>";
          });
          tabs += "</select>";
          data.tabs = tabs;
          return data;
        },
        onInsert: function(evt, node) {
          return $(node.el).find("select.nav").first().on("change", function(evt) {
            var $option;
            $option = $(this).find("option:selected");
            return $(node.el).find("input[type=\"hidden\"]").first().val($option.attr("value"));
          });
        }
      },
      optionfieldset: {
        template: "<div<% if (node.id) { %> id=\"<%= node.id %>\"<% } %>><%= children %></div>"
      },
      section: {
        template: "<div<% if (node.id) { %> id=\"<%= node.id %>\"<% } %>><%= children %></div>"
      },
      /*
      		A "questions" field renders a series of question fields and binds the
      		result to the value of a schema key.
      */

      questions: {
        template: "<div><input type=\"hidden\" id=\"<%= node.id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" /><%= children %></div>",
        fieldtempate: true,
        inputfield: true,
        getElement: function(el) {
          return $(el).parent().get(0);
        },
        onInsert: function(evt, node) {
          if (!node.children || (node.children.length === 0)) {
            return;
          }
          _.each(node.children, function(child) {
            return $(child.el).hide();
          });
          return $(node.children[0].el).show();
        }
      },
      /*
      		A "question" field lets user choose a response among possible choices.
      		The field is not associated with any schema key. A question should be
      		part of a "questions" field that binds a series of questions to a
      		schema key.
      */

      question: {
        template: "<div id=\"<%= node.id %>\"><% _.each(node.options, function(key, val) { %><label class=\"radio<%= (node.formElement.optionsType === \"radiobuttons\") ? \" btn\" : \"\" %><%= ((key instanceof Object && key.htmlClass) ? \" \" + key.htmlClass : \"\") %>\"><input type=\"radio\" <% if (node.formElement.optionsType === \"radiobuttons\") { %> style=\"position:absolute;left:-9999px;\" <% } %>name=\"<%= node.id %>\" value=\"<%= val %>\"<%= (node.disabled? \" disabled\" : \"\")%>/><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>",
        fieldtemplate: true,
        onInsert: function(evt, node) {
          var activeClass, elt;
          activeClass = "active";
          elt = node.formElement || {};
          if (elt.activeClass) {
            activeClass += " " + elt.activeClass;
          }
          return $(node.el).find("input[type=\"radio\"]").on("change", function(evt) {
            var option, questionNode;
            questionNode = null;
            option = node.options[$(this).val()];
            if (!node.parentNode || !node.parentNode.el) {
              return;
            }
            $(this).parent().parent().find("label").removeClass(activeClass);
            $(this).parent().addClass(activeClass);
            $(node.el).nextAll().hide();
            $(node.el).nextAll().find("input[type=\"radio\"]").prop("checked", false);
            if (option.value) {
              $(node.parentNode.el).find("input[type=\"hidden\"]").val(option.value);
            }
            if (option.next) {
              questionNode = _.find(node.parentNode.children, function(child) {
                return child.formElement && (child.formElement.qid === option.next);
              });
              $(questionNode.el).show();
              $(questionNode.el).nextAll().hide();
              $(questionNode.el).nextAll().find("input[type=\"radio\"]").prop("checked", false);
            }
            if (option.href) {
              if (option.target) {
                window.open(option.href, option.target);
              } else {
                window.location = option.href;
              }
            }
            if (option.submit) {
              return setTimeout((function() {
                return node.ownerTree.submit();
              }), 0);
            }
          });
        }
      }
    };
    /*
    	Retrieves the key identified by a path selector in the structured object.
    	
    	Levels in the path are separated by a dot. Array items are marked
    	with [x]. For instance:
    	foo.bar[3].baz
    	
    	@function
    	@param {Object} obj Structured object to parse
    	@param {String} key Path to the key to retrieve
    	@param {boolean} ignoreArrays True to use first element in an array when
    	stucked on a property. This parameter is basically only useful when
    	parsing a JSON schema for which the "items" property may either be an
    	object or an array with one object (only one because JSON form does not
    	support mix of items for arrays).
    	@return {Object} The key's value.
    */

    jsonform.util.getObjKey = function(obj, key, ignoreArrays) {
      var arrayMatch, i, innerobj, keyparts, subkey;
      innerobj = obj;
      keyparts = key.split(".");
      subkey = null;
      arrayMatch = null;
      i = 0;
      while (i < keyparts.length) {
        if ((innerobj === null) || (typeof innerobj !== "object")) {
          return null;
        }
        subkey = keyparts[i];
        arrayMatch = subkey.match(reArraySingle);
        if (arrayMatch) {
          subkey = subkey.replace(reArraySingle, "");
          if (!_.isArray(innerobj[subkey])) {
            return null;
          }
          innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)];
        } else if (ignoreArrays && !innerobj[subkey] && _.isArray(innerobj) && innerobj[0]) {
          innerobj = innerobj[0][subkey];
        } else {
          innerobj = innerobj[subkey];
        }
        i++;
      }
      if (ignoreArrays && _.isArray(innerobj) && innerobj[0]) {
        return innerobj[0];
      } else {
        return innerobj;
      }
    };
    /*
    	Sets the key identified by a path selector to the given value.
    	
    	Levels in the path are separated by a dot. Array items are marked
    	with [x]. For instance:
    	foo.bar[3].baz
    	
    	The hierarchy is automatically created if it does not exist yet.
    	
    	@function
    	@param {Object} obj The object to build
    	@param {String} key The path to the key to set where each level
    	is separated by a dot, and array items are flagged with [x].
    	@param {Object} value The value to set, may be of any type.
    */

    jsonform.util.setObjKey = function(obj, key, value) {
      var arrayMatch, i, innerobj, keyparts, subkey;
      innerobj = obj;
      keyparts = key.split(".");
      subkey = null;
      arrayMatch = null;
      i = 0;
      while (i < keyparts.length - 1) {
        subkey = keyparts[i];
        arrayMatch = subkey.match(reArraySingle);
        if (arrayMatch) {
          subkey = subkey.replace(reArraySingle, "");
          if (!_.isArray(innerobj[subkey])) {
            innerobj[subkey] = [];
          }
          if ((typeof innerobj[subkey][parseInt(arrayMatch[1], 10)] !== "object") || (innerobj[subkey][parseInt(arrayMatch[1], 10)] === null)) {
            innerobj[subkey][parseInt(arrayMatch[1], 10)] = {};
          }
          innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)];
        } else {
          if ((typeof innerobj[subkey] !== "object") || (innerobj[subkey] === null)) {
            innerobj[subkey] = {};
          }
          innerobj = innerobj[subkey];
        }
        i++;
      }
      subkey = keyparts[keyparts.length - 1];
      arrayMatch = subkey.match(reArraySingle);
      if (arrayMatch) {
        subkey = subkey.replace(reArraySingle, "");
        if (!_.isArray(innerobj[subkey])) {
          innerobj[subkey] = [];
        }
        return innerobj[subkey][parseInt(arrayMatch[1], 10)] = value;
      } else {
        return innerobj[subkey] = value;
      }
    };
    /*
    	Retrieves the key definition from the given schema.
    	
    	The key is identified by the path that leads to the key in the
    	structured object that the schema would generate. Each level is
    	separated by a '.'. Array levels are marked with []. For instance:
    	foo.bar[].baz
    	... to retrieve the definition of the key at the following location
    	in the JSON schema (using a dotted path notation):
    	foo.properties.bar.items.properties.baz
    	
    	@function
    	@param {Object} schema The JSON schema to retrieve the key from
    	@param {String} key The path to the key, each level being separated
    	by a dot and array items being flagged with [].
    	@return {Object} The key definition in the schema, null if not found.
    */

    getSchemaKey = function(schema, key) {
      var schemaKey;
      schemaKey = key.replace(/\./g, ".properties.").replace(/\[[0-9]*\](\.|$)/g, ".items$1");
      return jsonform.util.getObjKey(schema, schemaKey, true);
    };
    /*
    	Truncates the key path to the requested depth.
    	
    	For instance, if the key path is:
    	foo.bar[].baz.toto[].truc[].bidule
    	and the requested depth is 1, the returned key will be:
    	foo.bar[].baz.toto
    	
    	Note the function includes the path up to the next depth level.
    	
    	@function
    	@param {String} key The path to the key in the schema, each level being
    	separated by a dot and array items being flagged with [].
    	@param {Number} depth The array depth
    	@return {String} The path to the key truncated to the given depth.
    */

    truncateToArrayDepth = function(key, arrayDepth) {
      var depth, pos;
      depth = 0;
      pos = 0;
      if (!key) {
        return null;
      }
      if (arrayDepth > 0) {
        while (depth < arrayDepth) {
          pos = key.indexOf("[]", pos);
          if (pos === -1) {
            return key;
          }
          pos = pos + 2;
          depth += 1;
        }
      }
      pos = key.indexOf("[]", pos);
      if (pos === -1) {
        return key;
      } else {
        return key.substring(0, pos);
      }
    };
    /*
    	Applies the array path to the key path.
    	
    	For instance, if the key path is:
    	foo.bar[].baz.toto[].truc[].bidule
    	and the arrayPath [4, 2], the returned key will be:
    	foo.bar[4].baz.toto[2].truc[].bidule
    	
    	@function
    	@param {String} key The path to the key in the schema, each level being
    	separated by a dot and array items being flagged with [].
    	@param {Array(Number)} arrayPath The array path to apply, e.g. [4, 2]
    	@return {String} The path to the key that matches the array path.
    */

    applyArrayPath = function(key, arrayPath) {
      var depth, newKey;
      depth = 0;
      if (!key) {
        return null;
      }
      if (!arrayPath || (arrayPath.length === 0)) {
        return key;
      }
      newKey = key.replace(reArray, function(str, p1) {
        var newIndex;
        newIndex = str;
        if (!_.isUndefined(arrayPath[depth]) && !_.isNull(arrayPath[depth])) {
          newIndex = "[" + arrayPath[depth] + "]";
        }
        depth += 1;
        return newIndex;
      });
      return newKey;
    };
    /*
    	Returns the initial value that a field identified by its key
    	should take.
    	
    	The "initial" value is defined as:
    	1. the previously submitted value if already submitted
    	2. the default value defined in the layout of the form
    	3. the default value defined in the schema
    	
    	The "value" returned is intended for rendering purpose,
    	meaning that, for fields that define a titleMap property,
    	the function returns the label, and not the intrinsic value.
    	
    	The function handles values that contains template strings,
    	e.g. {{values.foo[].bar}} or {{idx}}.
    	
    	When the form is a string, the function truncates the resulting string
    	to meet a potential "maxLength" constraint defined in the schema, using
    	"..." to mark the truncation. Note it does not validate the resulting
    	string against other constraints (e.g. minLength, pattern) as it would
    	be hard to come up with an automated course of action to "fix" the value.
    	
    	@function
    	@param {Object} formObject The JSON Form object
    	@param {String} key The generic key path (e.g. foo[].bar.baz[])
    	@param {Array(Number)} arrayPath The array path that identifies
    	the unique value in the submitted form (e.g. [1, 3])
    	@param {Object} tpldata Template data object
    	@param {Boolean} usePreviousValues true to use previously submitted values
    	if defined.
    */

    getInitialValue = function(formObject, key, arrayPath, tpldata, usePreviousValues) {
      var formElement, getFormElement, schemaElement, value;
      value = null;
      tpldata = tpldata || {};
      tpldata.idx = tpldata.idx || (arrayPath ? arrayPath[arrayPath.length - 1] : 1);
      tpldata.value = tpldata.value || "";
      tpldata.getValue = tpldata.getValue || function(key) {
        return getInitialValue(formObject, key, arrayPath, tpldata, usePreviousValues);
      };
      getFormElement = function(elements, key) {
        var formElement;
        formElement = null;
        if (!elements || !elements.length) {
          return null;
        }
        _.each(elements, function(elt) {
          if (formElement) {
            return;
          }
          if (elt === key) {
            formElement = {
              key: elt
            };
            return;
          }
          if (_.isString(elt)) {
            return;
          }
          if (elt.key === key) {
            return formElement = elt;
          } else {
            if (elt.items) {
              return formElement = getFormElement(elt.items, key);
            }
          }
        });
        return formElement;
      };
      formElement = getFormElement(formObject.form || [], key);
      schemaElement = getSchemaKey(formObject.schema.properties, key);
      if (usePreviousValues && formObject.value) {
        value = jsonform.util.getObjKey(formObject.value, applyArrayPath(key, arrayPath));
      }
      if ((typeof value === "undefined") || (value === null)) {
        if (formElement && (typeof formElement["value"] !== "undefined")) {
          value = formElement["value"];
        } else {
          if (schemaElement) {
            value = schemaElement["default"] || "";
          }
        }
        if (value && value.indexOf("{{values.") !== -1) {
          value = value.replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}");
        }
        if (value) {
          value = _.template(value, tpldata, valueTemplateSettings);
        }
      }
      if ((typeof value !== "undefined") && (value !== null) && formElement && formElement.titleMap && formElement.titleMap[value]) {
        value = _.template(formElement.titleMap[value], tpldata, valueTemplateSettings);
      }
      if (value && _.isString(value) && schemaElement && schemaElement.maxLength ? value.length > schemaElement.maxLength : void 0) {
        value = value.substr(0, schemaElement.maxLength - 1) + "...";
      }
      if (typeof value === "undefined") {
        return null;
      } else {
        return value;
      }
    };
    /*
    	Represents a node in the form.
    	
    	Nodes that have an ID are linked to the corresponding DOM element
    	when rendered
    	
    	Note the form element and the schema elements that gave birth to the
    	node may be shared among multiple nodes (in the case of arrays).
    	
    	@class
    */

    formNode = function() {
      /*
      		The node's ID (may not be set)
      */
      this.id = null;
      /*
      		The node's key path (may not be set)
      */

      this.key = null;
      /*
      		DOM element associated witht the form element.
      		
      		The DOM element is set when the form element is rendered.
      */

      this.el = null;
      /*
      		Link to the form element that describes the node's layout
      		(note the form element is shared among nodes in arrays)
      */

      this.formElement = null;
      /*
      		Link to the schema element that describes the node's value constraints
      		(note the schema element is shared among nodes in arrays)
      */

      this.schemaElement = null;
      /*
      		Pointer to the "view" associated with the node, typically the right
      		object in jsonform.elementTypes
      */

      this.view = null;
      /*
      		Node's subtree (if one is defined)
      */

      this.children = [];
      /*
      		A pointer to the form tree the node is attached to
      */

      this.ownerTree = null;
      /*
      		A pointer to the parent node of the node in the tree
      */

      this.parentNode = null;
      /*
      		Child template for array-like nodes.
      		
      		The child template gets cloned to create new array items.
      */

      this.childTemplate = null;
      /*
      		Direct children of array-like containers may use the value of a
      		specific input field in their subtree as legend. The link to the
      		legend child is kept here and initialized in computeInitialValues
      		when a child sets "valueInLegend"
      */

      this.legendChild = null;
      /*
      		The path of indexes that lead to the current node when the
      		form element is not at the root array level.
      		
      		Note a form element may well be nested element and still be
      		at the root array level. That's typically the case for "fieldset"
      		elements. An array level only gets created when a form element
      		is of type "array" (or a derivated type such as "tabarray").
      		
      		The array path of a form element linked to the foo[2].bar.baz[3].toto
      		element in the submitted values is [2, 3] for instance.
      		
      		The array path is typically used to compute the right ID for input
      		fields. It is also used to update positions when an array item is
      		created, moved around or suppressed.
      		
      		@type {Array(Number)}
      */

      this.arrayPath = [];
      /*
      		Position of the node in the list of children of its parents
      */

      return this.childPos = 0;
    };
    /*
    	Clones a node
    	
    	@function
    	@param {formNode} New parent node to attach the node to
    	@return {formNode} Cloned node
    */

    formNode.prototype.clone = function(parentNode) {
      var node;
      node = new formNode();
      node.arrayPath = _.clone(this.arrayPath);
      node.ownerTree = this.ownerTree;
      node.parentNode = parentNode || this.parentNode;
      node.formElement = this.formElement;
      node.schemaElement = this.schemaElement;
      node.view = this.view;
      node.children = _.map(this.children, function(child) {
        return child.clone(node);
      });
      if (this.childTemplate) {
        node.childTemplate = this.childTemplate.clone(node);
      }
      return node;
    };
    /*
    	Returns true if the subtree that starts at the current node
    	has some non empty value attached to it
    */

    formNode.prototype.hasNonDefaultValue = function() {
      var child;
      if (this.formElement && this.formElement.type === "hidden") {
        return false;
      }
      if (this.value && !this.defaultValue) {
        return true;
      }
      child = _.find(this.children, function(child) {
        return child.hasNonDefaultValue();
      });
      return !!child;
    };
    /*
    	Attaches a child node to the current node.
    	
    	The child node is appended to the end of the list.
    	
    	@function
    	@param {formNode} node The child node to append
    	@return {formNode} The inserted node (same as the one given as parameter)
    */

    formNode.prototype.appendChild = function(node) {
      node.parentNode = this;
      node.childPos = this.children.length;
      this.children.push(node);
      return node;
    };
    /*
    	Removes the last child of the node.
    	
    	@function
    */

    formNode.prototype.removeChild = function() {
      var child;
      child = this.children[this.children.length - 1];
      if (!child) {
        return;
      }
      $(child.el).remove();
      return this.children.pop();
    };
    /*
    	Moves the user entered values set in the current node's subtree to the
    	given node's subtree.
    	
    	The target node must follow the same structure as the current node
    	(typically, they should have been generated from the same node template)
    	
    	The current node MUST be rendered in the DOM.
    	
    	TODO: when current node is not in the DOM, extract values from formNode.value
    	properties, so that the function be available even when current node is not
    	in the DOM.
    	
    	Moving values around allows to insert/remove array items at arbitrary
    	positions.
    	
    	@function
    	@param {formNode} node Target node.
    */

    formNode.prototype.moveValuesTo = function(node) {
      var values;
      values = this.getFormValues(node.arrayPath);
      node.resetValues();
      return node.computeInitialValues(values, true);
    };
    /*
    	Switches nodes user entered values.
    	
    	The target node must follow the same structure as the current node
    	(typically, they should have been generated from the same node template)
    	
    	Both nodes MUST be rendered in the DOM.
    	
    	TODO: update getFormValues to work even if node is not rendered, using
    	formNode's "value" property.
    	
    	@function
    	@param {formNode} node Target node
    */

    formNode.prototype.switchValuesWith = function(node) {
      var nodeValues, values;
      values = this.getFormValues(node.arrayPath);
      nodeValues = node.getFormValues(this.arrayPath);
      node.resetValues();
      node.computeInitialValues(values, true);
      this.resetValues();
      return this.computeInitialValues(nodeValues, true);
    };
    /*
    	Resets all DOM values in the node's subtree.
    	
    	This operation also drops all array item nodes.
    	Note values are not reset to their default values, they are rather removed!
    	
    	@function
    */

    formNode.prototype.resetValues = function() {
      var idx, params;
      params = null;
      idx = 0;
      this.value = null;
      if (this.parentNode) {
        this.arrayPath = _.clone(this.parentNode.arrayPath);
        if (this.parentNode.view && this.parentNode.view.array) {
          this.arrayPath.push(this.childPos);
        }
      } else {
        this.arrayPath = [];
      }
      if (this.view && this.view.inputfield) {
        params = $(":input", this.el).serializeArray();
        _.each(params, (function(param) {
          return $("[name=\"" + escapeSelector(param.name) + "\"]", $(this.el)).val("");
        }), this);
      } else {
        if (this.view && this.view.array) {
          while (this.children.length > 0) {
            this.removeChild();
          }
        }
      }
      return _.each(this.children, function(child) {
        return child.resetValues();
      });
    };
    /*
    	Sets the child template node for the current node.
    	
    	The child template node is used to create additional children
    	in an array-like form element. The template is never rendered.
    	
    	@function
    	@param {formNode} node The child template node to set
    */

    formNode.prototype.setChildTemplate = function(node) {
      this.childTemplate = node;
      return node.parentNode = this;
    };
    /*
    	Recursively sets values to all nodes of the current subtree
    	based on previously submitted values, or based on default
    	values when the submitted values are not enough
    	
    	The function should be called once in the lifetime of a node
    	in the tree. It expects its parent's arrayPath to be up to date.
    	
    	Three cases may arise:
    	1. if the form element is a simple input field, the value is
    	extracted from previously submitted values of from default values
    	defined in the schema.
    	2. if the form element is an array-like node, the child template
    	is used to create as many children as possible (and at least one).
    	3. the function simply recurses down the node's subtree otherwise
    	(this happens when the form element is a fieldset-like element).
    	
    	@function
    	@param {Object} values Previously submitted values for the form
    	@param {Boolean} ignoreDefaultValues Ignore default values defined in the
    	schema when set.
    */

    formNode.prototype.computeInitialValues = function(values, ignoreDefaultValues) {
      var formData, i, nbChildren, node, self, _results;
      self = this;
      node = null;
      nbChildren = 1;
      i = 0;
      formData = this.ownerTree.formDesc.tpldata || {};
      if (this.parentNode) {
        this.arrayPath = _.clone(this.parentNode.arrayPath);
        if (this.parentNode.view && this.parentNode.view.array) {
          this.arrayPath.push(this.childPos);
        }
      } else {
        this.arrayPath = [];
      }
      formData.idx = (this.arrayPath.length > 0 ? this.arrayPath[this.arrayPath.length - 1] + 1 : this.childPos + 1);
      formData.value = "";
      formData.getValue = function(key) {
        return getInitialValue(self.ownerTree.formDesc, key, self.arrayPath, formData, !!values);
      };
      if (this.formElement) {
        if (this.formElement.id) {
          this.id = applyArrayPath(this.formElement.id, this.arrayPath);
        } else if (this.view && this.view.array) {
          this.id = escapeSelector(this.ownerTree.formDesc.prefix) + "-elt-counter-" + _.uniqueId();
        } else if (this.parentNode && this.parentNode.view && this.parentNode.view.array) {
          this.id = escapeSelector(this.ownerTree.formDesc.prefix) + "-elt-counter-" + _.uniqueId();
        } else {
          if ((this.formElement.type === "button") || (this.formElement.type === "selectfieldset") || (this.formElement.type === "question") || (this.formElement.type === "buttonquestion")) {
            this.id = escapeSelector(this.ownerTree.formDesc.prefix) + "-elt-counter-" + _.uniqueId();
          }
        }
        if (this.formElement.key) {
          this.key = applyArrayPath(this.formElement.key, this.arrayPath);
          this.keydash = this.key.replace(/\./g, "---");
        }
        this.name = applyArrayPath(this.formElement.name, this.arrayPath);
        _.each(["title", "legend", "description", "append", "prepend", "inlinetitle", "helpvalue", "value", "disabled"], (function(prop) {
          if (_.isString(this.formElement[prop])) {
            if (this.formElement[prop].indexOf("{{values.") !== -1) {
              this[prop] = this.formElement[prop].replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}");
            } else {
              this[prop] = applyArrayPath(this.formElement[prop], this.arrayPath);
            }
            if (this[prop]) {
              return this[prop] = _.template(this[prop], formData, valueTemplateSettings);
            }
          } else {
            return this[prop] = this.formElement[prop];
          }
        }), this);
        if (this.formElement.options) {
          this.options = _.map(this.formElement.options, function(option) {
            var title;
            title = null;
            if (_.isObject(option) && option.title) {
              if (option.title.indexOf("{{values.") !== -1) {
                title = option.title.replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}");
              } else {
                title = applyArrayPath(option.title, self.arrayPath);
              }
              return _.extend({}, option, {
                value: (typeof option.value !== "undefined" ? option.value : ""),
                title: _.template(title, formData, valueTemplateSettings)
              });
            } else {
              return option;
            }
          });
        }
      }
      if (this.view && this.view.inputfield && this.schemaElement) {
        if (values) {
          if (jsonform.util.getObjKey(values, this.key)) {
            this.value = jsonform.util.getObjKey(values, this.key);
          }
        } else if (!ignoreDefaultValues) {
          if (!this.value && this.schemaElement["default"]) {
            this.value = this.schemaElement["default"];
            if (_.isString(this.value)) {
              if (this.value.indexOf("{{values.") !== -1) {
                this.value = this.value.replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}");
              } else {
                this.value = applyArrayPath(this.value, this.arrayPath);
              }
              if (this.value) {
                this.value = _.template(this.value, formData, valueTemplateSettings);
              }
            }
            this.defaultValue = true;
          }
        }
      } else if (this.view && this.view.array) {
        nbChildren = 0;
        if (values) {
          nbChildren = this.getPreviousNumberOfItems(values, this.arrayPath);
        }
        if (nbChildren === 0) {
          nbChildren = 1;
        }
        i = 0;
        while (i < nbChildren) {
          this.appendChild(this.childTemplate.clone());
          i++;
        }
      }
      _.each(this.children, function(child) {
        return child.computeInitialValues(values, ignoreDefaultValues);
      });
      if (this.formElement && this.formElement.valueInLegend) {
        node = this;
        _results = [];
        while (node) {
          if (node.parentNode && node.parentNode.view && node.parentNode.view.array) {
            node.legendChild = this;
            if (node.formElement && node.formElement.legend) {
              node.legend = applyArrayPath(node.formElement.legend, node.arrayPath);
              formData.idx = (node.arrayPath.length > 0 ? node.arrayPath[node.arrayPath.length - 1] + 1 : node.childPos + 1);
              formData.value = this.value || "";
              node.legend = _.template(node.legend, formData, valueTemplateSettings);
              break;
            }
          }
          _results.push(node = node.parentNode);
        }
        return _results;
      }
    };
    /*
    	Returns the number of items that the array node should have based on
    	previously submitted values.
    	
    	The whole difficulty is that values may be hidden deep in the subtree
    	of the node and may actually target different arrays in the JSON schema.
    	
    	@function
    	@param {Object} values Previously submitted values
    	@param {Array(Number)} arrayPath the array path we're interested in
    	@return {Number} The number of items in the array
    */

    formNode.prototype.getPreviousNumberOfItems = function(values, arrayPath) {
      var arrayValue, childNumbers, idx, key;
      key = null;
      arrayValue = null;
      childNumbers = null;
      idx = 0;
      if (!values) {
        return 0;
      }
      if (this.view.inputfield && this.schemaElement) {
        key = truncateToArrayDepth(this.formElement.key, arrayPath.length);
        key = applyArrayPath(key, arrayPath);
        arrayValue = jsonform.util.getObjKey(values, key);
        if (!arrayValue) {
          return 0;
        }
        childNumbers = _.map(this.children, function(child) {
          return child.getPreviousNumberOfItems(values, arrayPath);
        });
        return _.max([_.max(childNumbers) || 0, arrayValue.length]);
      } else if (this.view.array) {
        return this.childTemplate.getPreviousNumberOfItems(values, arrayPath);
      } else {
        childNumbers = _.map(this.children, function(child) {
          return child.getPreviousNumberOfItems(values, arrayPath);
        });
        return _.max(childNumbers) || 0;
      }
    };
    /*
    	Returns the structured object that corresponds to the form values entered
    	by the user for the node's subtree.
    	
    	The returned object follows the structure of the JSON schema that gave
    	birth to the form.
    	
    	Obviously, the node must have been rendered before that function may
    	be called.
    	
    	@function
    	@param {Array(Number)} updateArrayPath Array path to use to pretend that
    	the entered values were actually entered for another item in an array
    	(this is used to move values around when an item is inserted/removed/moved
    	in an array)
    	@return {Object} The object that follows the data schema and matches the
    	values entered by the user.
    */

    formNode.prototype.getFormValues = function(updateArrayPath) {
      var arrayMatch, cval, eltSchema, formArray, formSchema, i, name, values;
      values = {};
      if (!this.el) {
        throw new Error("formNode.getFormValues can only be called on nodes that are associated with a DOM element in the tree");
      }
      formArray = $(":input", this.el).serializeArray();
      if (updateArrayPath) {
        _.each(formArray, function(param) {
          return param.name = applyArrayPath(param.name, updateArrayPath);
        });
      }
      formSchema = this.ownerTree.formDesc.schema;
      i = 0;
      while (i < formArray.length) {
        name = formArray[i].name;
        eltSchema = getSchemaKey(formSchema.properties, name);
        arrayMatch = null;
        cval = null;
        if (!eltSchema) {
          continue;
        }
        if (eltSchema._jsonform_checkboxes_as_array) {
          arrayMatch = name.match(/\[([0-9]*)\]$/);
          if (arrayMatch) {
            name = name.replace(/\[([0-9]*)\]$/, "");
            cval = jsonform.util.getObjKey(values, name) || [];
            if (formArray[i].value === "1") {
              cval.push(eltSchema["enum"][parseInt(arrayMatch[1], 10)]);
            }
            jsonform.util.setObjKey(values, name, cval);
            continue;
          }
        }
        if (eltSchema.type === "boolean") {
          if (formArray[i].value === "0") {
            formArray[i].value = false;
          } else {
            formArray[i].value = !!formArray[i].value;
          }
        }
        if ((eltSchema.type === "number") || (eltSchema.type === "integer")) {
          if (_.isString(formArray[i].value)) {
            if (!formArray[i].value.length) {
              formArray[i].value = undefined;
            } else {
              if (!isNaN(Number(formArray[i].value))) {
                formArray[i].value = Number(formArray[i].value);
              }
            }
          }
        }
        if ((eltSchema.type === "string") && (formArray[i].value === "") && !eltSchema._jsonform_allowEmpty) {
          formArray[i].value = null;
        }
        if ((eltSchema.type === "object") && _.isString(formArray[i].value) && (formArray[i].value.substring(0, 1) === "{")) {
          try {
            formArray[i].value = JSON.parse(formArray[i].value);
          } catch (e) {
            formArray[i].value = {};
          }
        }
        if ((eltSchema.type === "object") && (formArray[i].value === "null" || formArray[i].value === "")) {
          formArray[i].value = null;
        }
        if (formArray[i].name && (formArray[i].value !== null)) {
          jsonform.util.setObjKey(values, formArray[i].name, formArray[i].value);
        }
        i++;
      }
      return values;
    };
    /*
    	Renders the node.
    	
    	Rendering is done in three steps: HTML generation, DOM element creation
    	and insertion, and an enhance step to bind event handlers.
    	
    	@function
    	@param {Node} el The DOM element where the node is to be rendered. The
    	node is inserted at the right position based on its "childPos" property.
    */

    formNode.prototype.render = function(el) {
      var html;
      html = this.generate();
      this.setContent(html, el);
      return this.enhance();
    };
    /*
    	Inserts/Updates the HTML content of the node in the DOM.
    	
    	If the HTML is an update, the new HTML content replaces the old one.
    	The new HTML content is not moved around in the DOM in particular.
    	
    	The HTML is inserted at the right position in its parent's DOM subtree
    	otherwise (well, provided there are enough children, but that should always
    	be the case).
    	
    	@function
    	@param {string} html The HTML content to render
    	@param {Node} parentEl The DOM element that is to contain the DOM node.
    	This parameter is optional (the node's parent is used otherwise) and
    	is ignored if the node to render is already in the DOM tree.
    */

    formNode.prototype.setContent = function(html, parentEl) {
      var nextSibling, node, parentNode;
      node = $(html);
      parentNode = parentEl || (this.parentNode ? this.parentNode.el : this.ownerTree.domRoot);
      nextSibling = null;
      if (this.el) {
        $(this.el).replaceWith(node);
      } else {
        nextSibling = $(parentNode).children().get(this.childPos);
        if (nextSibling) {
          $(nextSibling).before(node);
        } else {
          $(parentNode).append(node);
        }
      }
      this.el = node;
      return this.updateElement(this.el);
    };
    /*
    	Updates the DOM element associated with the node.
    	
    	Only nodes that have ID are directly associated with a DOM element.
    	
    	@function
    */

    formNode.prototype.updateElement = function(domNode) {
      if (this.id) {
        this.el = $("#" + escapeSelector(this.id), domNode).get(0);
        if (this.view && this.view.getElement) {
          this.el = this.view.getElement(this.el);
        }
        if ((this.fieldtemplate !== false) && this.view && this.view.fieldtemplate) {
          this.el = $(this.el).parent().parent();
          if (this.prepend || this.prepend) {
            this.el = this.el.parent();
          }
          this.el = this.el.get(0);
        }
        if (this.parentNode && this.parentNode.view && this.parentNode.view.childTemplate) {
          this.el = $(this.el).parent().get(0);
        }
      }
      return _.each(this.children, function(child) {
        return child.updateElement(this.el || domNode);
      });
    };
    /*
    	Generates the view's HTML content for the underlying model.
    	
    	@function
    */

    formNode.prototype.generate = function() {
      var childrenhtml, data, html, template;
      data = {
        id: this.id,
        keydash: this.keydash,
        elt: this.formElement,
        schema: this.schemaElement,
        node: this,
        value: this.value || "",
        escape: escapeHTML
      };
      template = null;
      html = "";
      if (this.ownerTree.formDesc.onBeforeRender) {
        this.ownerTree.formDesc.onBeforeRender(data, this);
      }
      if (this.view.onBeforeRender) {
        this.view.onBeforeRender(data, this);
      }
      if (this.template) {
        template = this.template;
      } else if (this.formElement && this.formElement.template) {
        template = this.formElement.template;
      } else {
        template = this.view.template;
      }
      if ((this.fieldtemplate !== false) && (this.fieldtemplate || this.view.fieldtemplate)) {
        template = jsonform.fieldTemplate(template);
      }
      if (this.parentNode && this.parentNode.view && this.parentNode.view.childTemplate) {
        template = this.parentNode.view.childTemplate(template);
      }
      childrenhtml = "";
      _.each(this.children, function(child) {
        return childrenhtml += child.generate();
      });
      data.children = childrenhtml;
      html = _.template(template, data, fieldTemplateSettings);
      return html;
    };
    /*
    	Enhances the view with additional logic, binding event handlers
    	in particular.
    	
    	The function also runs the "insert" event handler of the view and
    	form element if they exist (starting with that of the view)
    	
    	@function
    */

    formNode.prototype.enhance = function() {
      var formData, handler, handlers, node;
      node = this;
      handlers = null;
      handler = null;
      formData = _.clone(this.ownerTree.formDesc.tpldata) || {};
      if (this.formElement) {
        if (this.view.onInsert) {
          this.view.onInsert({
            target: $(this.el)
          }, this);
        }
        handlers = this.handlers || this.formElement.handlers;
        handler = this.onInsert || this.formElement.onInsert;
        if (handler) {
          handler({
            target: $(this.el)
          }, this);
        }
        if (handlers) {
          _.each(handlers, (function(handler, onevent) {
            if (onevent === "insert") {
              return handler({
                target: $(this.el)
              }, this);
            }
          }), this);
        }
        if (this.el) {
          if (this.onChange) {
            $(this.el).bind("change", function(evt) {
              return node.onChange(evt, node);
            });
          }
          if (this.view.onChange) {
            $(this.el).bind("change", function(evt) {
              return node.view.onChange(evt, node);
            });
          }
          if (this.formElement.onChange) {
            $(this.el).bind("change", function(evt) {
              return node.formElement.onChange(evt, node);
            });
          }
          if (this.onClick) {
            $(this.el).bind("click", function(evt) {
              return node.onClick(evt, node);
            });
          }
          if (this.view.onClick) {
            $(this.el).bind("click", function(evt) {
              return node.view.onClick(evt, node);
            });
          }
          if (this.formElement.onClick) {
            $(this.el).bind("click", function(evt) {
              return node.formElement.onClick(evt, node);
            });
          }
          if (this.onKeyUp) {
            $(this.el).bind("keyup", function(evt) {
              return node.onKeyUp(evt, node);
            });
          }
          if (this.view.onKeyUp) {
            $(this.el).bind("keyup", function(evt) {
              return node.view.onKeyUp(evt, node);
            });
          }
          if (this.formElement.onKeyUp) {
            $(this.el).bind("keyup", function(evt) {
              return node.formElement.onKeyUp(evt, node);
            });
          }
          if (handlers) {
            _.each(handlers, (function(handler, onevent) {
              if (onevent !== "insert") {
                return $(this.el).bind(onevent, function(evt) {
                  return handler(evt, node);
                });
              }
            }), this);
          }
        }
        if (this.legendChild && this.legendChild.formElement) {
          $(this.legendChild.el).bind("keyup", function(evt) {
            if (node.formElement && node.formElement.legend && node.parentNode) {
              node.legend = applyArrayPath(node.formElement.legend, node.arrayPath);
              formData.idx = (node.arrayPath.length > 0 ? node.arrayPath[node.arrayPath.length - 1] + 1 : node.childPos + 1);
              formData.value = $(evt.target).val();
              node.legend = _.template(node.legend, formData, valueTemplateSettings);
              return $(node.parentNode.el).trigger("legendUpdated");
            }
          });
        }
      }
      return _.each(this.children, function(child) {
        return child.enhance();
      });
    };
    /*
    	Inserts an item in the array at the requested position and renders the item.
    	
    	@function
    	@param {Number} idx Insertion index
    */

    formNode.prototype.insertArrayItem = function(idx, domElement) {
      var child, i, _results;
      i = 0;
      if (idx === undefined) {
        idx = this.children.length;
      }
      child = this.childTemplate.clone();
      this.appendChild(child);
      child.resetValues();
      i = this.children.length - 2;
      while (i >= idx) {
        this.children[i].moveValuesTo(this.children[i + 1]);
        i--;
      }
      this.children[idx].resetValues();
      this.children[idx].computeInitialValues();
      i = idx;
      _results = [];
      while (i < this.children.length) {
        this.children[i].render(domElement);
        _results.push(i++);
      }
      return _results;
    };
    /*
    	Remove an item from an array
    	
    	@function
    	@param {Number} idx The index number of the item to remove
    */

    formNode.prototype.deleteArrayItem = function(idx) {
      var child, i;
      i = 0;
      child = null;
      if (idx === undefined) {
        idx = this.children.length - 1;
      }
      i = idx;
      while (i < this.children.length - 1) {
        this.children[i + 1].moveValuesTo(this.children[i]);
        this.children[i].render();
        i++;
      }
      if (this.children.length > 1) {
        return this.removeChild();
      } else {
        this.children[0].resetValues();
        this.children[0].computeInitialValues();
        return this.children[0].render();
      }
    };
    /*
    	Returns the minimum/maximum number of items that an array field
    	is allowed to have according to the schema definition of the fields
    	it contains.
    	
    	The function parses the schema definitions of the array items that
    	compose the current "array" node and returns the minimum value of
    	"maxItems" it encounters as the maximum number of items, and the
    	maximum value of "minItems" as the minimum number of items.
    	
    	The function reports a -1 for either of the boundaries if the schema
    	does not put any constraint on the number of elements the current
    	array may have of if the current node is not an array.
    	
    	Note that array boundaries should be defined in the JSON Schema using
    	"minItems" and "maxItems". The code also supports "minLength" and
    	"maxLength" as a fallback, mostly because it used to by mistake (see #22)
    	and because other people could make the same mistake.
    	
    	@function
    	@return {Object} An object with properties "minItems" and "maxItems"
    	that reports the corresponding number of items that the array may
    	have (value is -1 when there is no constraint for that boundary)
    */

    formNode.prototype.getArrayBoundaries = function() {
      var boundaries, getNodeBoundaries;
      boundaries = {
        minItems: -1,
        maxItems: -1
      };
      if (!this.view || !this.view.array) {
        return boundaries;
      }
      getNodeBoundaries = function(node, initialNode) {
        var schemaKey;
        schemaKey = null;
        boundaries = {
          minItems: -1,
          maxItems: -1
        };
        initialNode = initialNode || node;
        if (node.view && node.view.array && (node !== initialNode)) {
          return boundaries;
        }
        if (node.key) {
          schemaKey = getSchemaKey(node.ownerTree.formDesc.schema.properties, node.key.replace(/\[[0-9]+\]/g, "[]").replace(/\[\][^\[\]]*$/, ""));
          if (!schemaKey) {
            return boundaries;
          }
          return {
            minItems: schemaKey.minItems || schemaKey.minLength || -1,
            maxItems: schemaKey.maxItems || schemaKey.maxLength || -1
          };
        } else {
          _.each(node.children, function(child) {
            var subBoundaries;
            subBoundaries = getNodeBoundaries(child, initialNode);
            if (subBoundaries.minItems !== -1) {
              if (boundaries.minItems !== -1) {
                boundaries.minItems = Math.max(boundaries.minItems, subBoundaries.minItems);
              } else {
                boundaries.minItems = subBoundaries.minItems;
              }
            }
            if (subBoundaries.maxItems !== -1) {
              if (boundaries.maxItems !== -1) {
                return boundaries.maxItems = Math.min(boundaries.maxItems, subBoundaries.maxItems);
              } else {
                return boundaries.maxItems = subBoundaries.maxItems;
              }
            }
          });
        }
        return boundaries;
      };
      return getNodeBoundaries(this);
    };
    /*
    	Form tree class.
    	
    	Holds the internal representation of the form.
    	The tree is always in sync with the rendered form, this allows to parse
    	it easily.
    	
    	@class
    */

    formTree = function() {
      this.eventhandlers = [];
      this.root = null;
      return this.formDesc = null;
    };
    /*
    	Initializes the form tree structure from the JSONForm object
    	
    	This function is the main entry point of the JSONForm library.
    	
    	Initialization steps:
    	1. the internal tree structure that matches the JSONForm object
    	gets created (call to buildTree)
    	2. initial values are computed from previously submitted values
    	or from the default values defined in the JSON schema.
    	
    	When the function returns, the tree is ready to be rendered through
    	a call to "render".
    	
    	@function
    */

    formTree.prototype.initialize = function(formDesc) {
      formDesc = formDesc || {};
      this.formDesc = _.clone(formDesc);
      this.formDesc.prefix = this.formDesc.prefix || "jsonform-" + _.uniqueId();
      if (this.formDesc.schema && !this.formDesc.schema.properties) {
        this.formDesc.schema = {
          properties: this.formDesc.schema
        };
      }
      this.formDesc.form = this.formDesc.form || [
        "*", {
          type: "actions",
          items: [
            {
              type: "submit",
              value: "Submit"
            }
          ]
        }
      ];
      this.formDesc.form = (_.isArray(this.formDesc.form) ? this.formDesc.form : [this.formDesc.form]);
      this.root = new formNode();
      this.root.ownerTree = this;
      this.root.view = jsonform.elementTypes["root"];
      this.buildTree();
      return this.computeInitialValues();
    };
    /*
    	Constructs the tree from the form description.
    	
    	The function must be called once when the tree is first created.
    	
    	@function
    */

    formTree.prototype.buildTree = function() {
      return _.each(this.formDesc.form, (function(formElement) {
        if (formElement === "*") {
          return _.each(this.formDesc.schema.properties, (function(element, key) {
            return this.root.appendChild(this.buildFromLayout({
              key: key
            }));
          }), this);
        } else {
          if (_.isString(formElement)) {
            formElement = {
              key: formElement
            };
          }
          return this.root.appendChild(this.buildFromLayout(formElement));
        }
      }), this);
    };
    /*
    	Builds the internal form tree representation from the requested layout.
    	
    	The function is recursive, generating the node children as necessary.
    	The function extracts the values from the previously submitted values
    	(this.formDesc.value) or from default values defined in the schema.
    	
    	@function
    	@param {Object} formElement JSONForm element to render
    	@param {Object} context The parsing context (the array depth in particular)
    	@return {Object} The node that matches the element.
    */

    formTree.prototype.buildFromLayout = function(formElement, context) {
      var itemsEnum, key, node, schemaElement, view;
      schemaElement = null;
      node = new formNode();
      view = null;
      key = null;
      formElement = _.clone(formElement);
      if (formElement.items) {
        if (_.isArray(formElement.items)) {
          formElement.items = _.map(formElement.items, _.clone);
        } else {
          formElement.items = [_.clone(formElement.items)];
        }
      }
      if (formElement.key) {
        schemaElement = getSchemaKey(this.formDesc.schema.properties, formElement.key);
        if (!schemaElement) {
          throw new Error("The JSONForm object references the schema key \"" + formElement.key + "\" but that key does not exist in the JSON schema");
        }
        if (this.formDesc.onElementSchema) {
          this.formDesc.onElementSchema(formElement, schemaElement);
        }
        formElement.name = formElement.name || formElement.key;
        formElement.title = formElement.title || schemaElement.title;
        formElement.description = formElement.description || schemaElement.description;
        if (!formElement.id) {
          formElement.id = escapeSelector(this.formDesc.prefix) + "-elt-" + formElement.key;
        }
        if (formElement.allowEmpty) {
          schemaElement._jsonform_allowEmpty = true;
        }
        if (!formElement.type) {
          if ((schemaElement.type === "string") && (schemaElement.format === "color")) {
            formElement.type = "color";
          } else if ((schemaElement.type === "number" || schemaElement.type === "integer" || schemaElement.type === "string" || schemaElement.type === "any") && !schemaElement["enum"]) {
            formElement.type = "text";
          } else if (schemaElement.type === "boolean") {
            formElement.type = "checkbox";
          } else if (schemaElement.type === "object") {
            formElement.type = "fieldset";
          } else if (!_.isUndefined(schemaElement["enum"])) {
            formElement.type = "select";
          } else {
            formElement.type = schemaElement.type;
          }
        }
        if (!formElement.options && schemaElement["enum"]) {
          if (formElement.titleMap) {
            formElement.options = _.map(schemaElement["enum"], function(value) {
              return {
                value: value,
                title: formElement.titleMap[value] || value
              };
            });
          } else {
            formElement.options = schemaElement["enum"];
          }
        }
        if ((formElement.type === "checkboxes") && schemaElement.items) {
          itemsEnum = schemaElement.items["enum"];
          if (itemsEnum) {
            schemaElement.items._jsonform_checkboxes_as_array = true;
          }
          if (!itemsEnum && schemaElement.items[0]) {
            itemsEnum = schemaElement.items[0]["enum"];
            if (itemsEnum) {
              schemaElement.items[0]._jsonform_checkboxes_as_array = true;
            }
          }
        }
        if (schemaElement.type === "object") {
          _.each(schemaElement.properties, (function(prop, propName) {
            return node.appendChild(this.buildFromLayout({
              key: formElement.key + "." + propName
            }));
          }), this);
        }
      }
      if (!formElement.type) {
        if (formElement.parentNode) {
          formElement.type = "none";
        } else {
          formElement.type = "root";
        }
      }
      view = jsonform.elementTypes[formElement.type];
      if (!view) {
        throw new Error("The JSONForm contains an element whose type is unknown: \"" + formElement.type + "\"");
      }
      if (schemaElement) {
        if (!view.inputfield && !view.array && (formElement.type !== "selectfieldset") && (schemaElement.type !== "object")) {
          throw new Error("The JSONForm contains an element that links to an element in the JSON schema (key: \"" + formElement.key + "\") and that should not based on its type (\"" + formElement.type + "\")");
        }
      } else {
        if (view.inputfield && (formElement.type !== "selectfieldset")) {
          throw new Error("The JSONForm defines an element of type \"" + formElement.type + "\" but no \"key\" property to link the input field to the JSON schema");
        }
      }
      formElement.iddot = escapeSelector(formElement.id || "");
      node.formElement = formElement;
      node.schemaElement = schemaElement;
      node.view = view;
      node.ownerTree = this;
      if (!formElement.handlers) {
        formElement.handlers = {};
      }
      if (node.view.array) {
        if (formElement.items) {
          key = formElement.items[0] || formElement.items;
        } else {
          key = formElement.key + "[]";
        }
        if (_.isString(key)) {
          key = {
            key: key
          };
        }
        node.setChildTemplate(this.buildFromLayout(key));
      } else if (formElement.items) {
        _.each(formElement.items, (function(item) {
          if (_.isString(item)) {
            item = {
              key: item
            };
          }
          return node.appendChild(this.buildFromLayout(item));
        }), this);
      }
      return node;
    };
    /*
    	Computes the values associated with each input field in the tree based
    	on previously submitted values or default values in the JSON schema.
    	
    	For arrays, the function actually creates and inserts additional
    	nodes in the tree based on previously submitted values (also ensuring
    	that the array has at least one item).
    	
    	The function sets the array path on all nodes.
    	It should be called once in the lifetime of a form tree right after
    	the tree structure has been created.
    	
    	@function
    */

    formTree.prototype.computeInitialValues = function() {
      return this.root.computeInitialValues(this.formDesc.value);
    };
    /*
    	Renders the form tree
    	
    	@function
    	@param {Node} domRoot The "form" element in the DOM tree that serves as
    	root for the form
    */

    formTree.prototype.render = function(domRoot) {
      if (!domRoot) {
        return;
      }
      this.domRoot = domRoot;
      return this.root.render();
    };
    /*
    	Walks down the element tree with a callback
    	
    	@function
    	@param {Function} callback The callback to call on each element
    */

    formTree.prototype.forEachElement = function(callback) {
      var f;
      f = function(root) {
        var i, _results;
        i = 0;
        _results = [];
        while (i < root.children.length) {
          callback(root.children[i]);
          f(root.children[i]);
          _results.push(i++);
        }
        return _results;
      };
      return f(this.root);
    };
    formTree.prototype.validate = function(noErrorDisplay) {
      var errors, options, v, validator, values;
      values = jsonform.getFormValue(this.domRoot);
      errors = false;
      options = this.formDesc;
      if (options.validate !== false) {
        validator = false;
        if (typeof options.validate !== "object") {
          if (global.JSONFormValidator) {
            validator = global.JSONFormValidator.createEnvironment("json-schema-draft-03");
          }
        } else {
          validator = options.validate;
        }
        if (validator) {
          v = validator.validate(values, this.formDesc.schema);
          $(this.domRoot).jsonFormErrors(false, options);
          if (v.errors.length) {
            if (!errors) {
              errors = [];
            }
            errors = errors.concat(v.errors);
          }
        }
      }
      if (errors && !noErrorDisplay) {
        if (options.displayErrors) {
          options.displayErrors(errors, this.domRoot);
        } else {
          $(this.domRoot).jsonFormErrors(errors, options);
        }
      }
      return {
        errors: errors
      };
    };
    formTree.prototype.submit = function(evt) {
      var brk, options, stopEvent, validated, values;
      stopEvent = function() {
        if (evt) {
          evt.preventDefault();
          evt.stopPropagation();
        }
        return false;
      };
      values = jsonform.getFormValue(this.domRoot);
      options = this.formDesc;
      brk = false;
      this.forEachElement(function(elt) {
        if (brk) {
          return;
        }
        if (elt.view.onSubmit) {
          return brk = !elt.view.onSubmit(evt, elt);
        }
      });
      if (brk) {
        return stopEvent();
      }
      validated = this.validate();
      if (options.onSubmit && !options.onSubmit(validated.errors, values)) {
        return stopEvent();
      }
      if (validated.errors) {
        return stopEvent();
      }
      if (options.onSubmitValid && !options.onSubmitValid(values)) {
        return stopEvent();
      }
      return false;
    };
    /*
    	Returns the structured object that corresponds to the form values entered
    	by the use for the given form.
    	
    	The form must have been previously rendered through a call to jsonform.
    	
    	@function
    	@param {Node} The <form> tag in the DOM
    	@return {Object} The object that follows the data schema and matches the
    	values entered by the user.
    */

    jsonform.getFormValue = function(formelt) {
      var form;
      form = $(formelt).data("jsonform-tree");
      if (!form) {
        return null;
      }
      return form.root.getFormValues();
    };
    /*
    	Highlights errors reported by the JSON schema validator in the document.
    	
    	@function
    	@param {Object} errors List of errors reported by the JSON schema validator
    	@param {Object} options The JSON Form object that describes the form
    	(unused for the time being, could be useful to store example values or
    	specific error messages)
    */

    $.fn.jsonFormErrors = function(errors, options) {
      var errorType, errormarkerclass, i, key, _results;
      $(".error", this).removeClass("error");
      $(".warning", this).removeClass("warning");
      $(".jsonform-errortext", this).hide();
      if (!errors) {
        return;
      }
      i = 0;
      _results = [];
      while (i < errors.length) {
        key = errors[i].uri.replace(/.*#\//, "").replace(/\//g, ".").replace(/\.([0-9]+)(\.|$)/, "[$1]$2");
        errormarkerclass = ".jsonform-error-" + escapeSelector(key.replace(/\./g, "---"));
        errorType = errors[i].type || "error";
        $(errormarkerclass, this).addClass(errorType);
        $(errormarkerclass + " .jsonform-errortext", this).html(errors[i].message).show();
        _results.push(i++);
      }
      return _results;
    };
    /*
    	Generates the HTML form from the given JSON Form object and renders the form.
    	
    	Main entry point of the library. Defined as a jQuery function that typically
    	needs to be applied to a <form> element in the document.
    	
    	The function handles the following properties for the JSON Form object it
    	receives as parameter:
    	- schema (required): The JSON Schema that describes the form to render
    	- form: The options form layout description, overrides default layout
    	- prefix: String to use to prefix computed IDs. Default is an empty string.
    	Use this option if JSON Form is used multiple times in an application with
    	schemas that have overlapping parameter names to avoid running into multiple
    	IDs issues. Default value is "jsonform-[counter]".
    	- transloadit: Transloadit parameters when transloadit is used
    	- validate: Validates form against schema upon submission. Uses the value
    	of the "validate" property as validator if it is an object.
    	- displayErrors: Function to call with errors upon form submission.
    	Default is to render the errors next to the input fields.
    	- submitEvent: Name of the form submission event to bind to.
    	Default is "submit".
    	- onSubmit: Callback function to call when form is submitted
    	- onSubmitValid: Callback function to call when form is submitted without
    	errors.
    	
    	@function
    	@param {Object} options The JSON Form object to use as basis for the form
    */

    $.fn.jsonForm = function(options) {
      var form, formElt;
      formElt = this;
      options = options || {};
      form = new formTree();
      form.initialize(options);
      form.render(formElt.get(0));
      if (options.transloadit) {
        formElt.append("<input type=\"hidden\" name=\"params\" value='" + escapeHTML(JSON.stringify(options.transloadit.params)) + "'>");
      }
      formElt.data("jsonform-tree", form);
      formElt.unbind((options.submitEvent || "submit") + ".jsonform");
      formElt.bind((options.submitEvent || "submit") + ".jsonform", function(evt) {
        return form.submit(evt);
      });
      initializeTabs(formElt);
      $(".expandable > div, .expandable > fieldset", formElt).hide();
      $(".expandable > legend", formElt).click(function() {
        var parent;
        parent = $(this).parent();
        parent.toggleClass("expanded");
        return $("> div", parent).slideToggle(100);
      });
      return form;
    };
    /*
    	Retrieves the structured values object generated from the values
    	entered by the user and the data schema that gave birth to the form.
    	
    	Defined as a jQuery function that typically needs to be applied to
    	a <form> element whose content has previously been generated by a
    	call to "jsonForm".
    	
    	Unless explicitly disabled, the values are automatically validated
    	against the constraints expressed in the schema.
    	
    	@function
    	@return {Object} Structured values object that matches the user inputs
    	and the data schema.
    */

    $.fn.jsonFormValue = function() {
      return jsonform.getFormValue(this);
    };
    global.JSONForm = global.JSONForm || {
      util: {}
    };
    global.JSONForm.getFormValue = jsonform.getFormValue;
    global.JSONForm.fieldTemplate = jsonform.fieldTemplate;
    global.JSONForm.fieldTypes = jsonform.elementTypes;
    global.JSONForm.getInitialValue = getInitialValue;
    global.JSONForm.util.getObjKey = jsonform.util.getObjKey;
    return global.JSONForm.util.setObjKey = jsonform.util.setObjKey;
  })(typeof exports !== "undefined", (typeof exports !== "undefined" ? exports : window), (typeof jQuery !== "undefined" ? jQuery : {
    fn: {}
  }), (typeof _ !== "undefined" ? _ : null), JSON);

}).call(this);
