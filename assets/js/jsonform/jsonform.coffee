###
@fileoverview Core of the JSON Form client-side library.

Generates an HTML form from a structured data model and a layout description.

The library may also validate inputs entered by the user against the data model
upon form submission and create the structured data object initialized with the
values that were submitted.

The library depends on:
- jQuery
- the underscore library
- a JSON parser/serializer. Nothing to worry about in modern browsers.
- the JSONFormValidation library (in jsv.js) for validation purpose

See documentation at:
http://developer.joshfire.com/doc/dev/ref/jsonform

The library creates and maintains an internal data tree along with the DOM.
That structure is necessary to handle arrays (and nested arrays!) that are
dynamic by essence.
###

#global window
((serverside, global, $, _, JSON) ->
	###
	Regular expressions used to extract array indexes in input field names
	###
	reArray = /\[([0-9]*)\](?=\.|$)/g
	reArraySingle = /\[([0-9]*)\](?:\.|$)/
	
	###
	Template settings for form views
	###
	fieldTemplateSettings =
		evaluate: /<%([\s\S]+?)%>/g
		interpolate: /<%=([\s\S]+?)%>/g

	
	###
	Template settings for value replacement
	###
	valueTemplateSettings =
		evaluate: /\{\[([\s\S]+?)\]\}/g
		interpolate: /\{\{([\s\S]+?)\}\}/g

	
	###
	The jsonform object whose methods will be exposed to the window object
	###
	jsonform = util: {}
	
	# From backbonejs
	# TODO replace by (new Option(JSON.stringify(html))).innerHTML ?
	escapeHTML = (string) ->
		return ""  unless string
		("" + string).replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace /\//g, "&#x2F;"

	
	###
	Escapes selector name for use with jQuery
	
	All meta-characters listed in jQuery doc are escaped:
	http://api.jquery.com/category/selectors/
	
	@function
	@param {String} selector The jQuery selector to escape
	@return {String} The escaped selector.
	###
	escapeSelector = (selector) ->
		selector.replace /([\!\"\#\$\%\&\'\(\)\*\+\,\.\/\:\;<\=\>\?\@\[\\\]\^\`\{\|\}\~])/g, "\\$1"

	
	###
	Initializes tabular sections in forms. Such sections are generated by the
	'selectfieldset' type of elements in JSON Form.
	
	Input fields that are not visible are automatically disabled
	not to appear in the submitted form. That's on purpose, as tabs
	are meant to convey an alternative (and not a sequence of steps).
	
	The tabs menu is not rendered as tabs but rather as a select field because
	it's easier to grasp that it's an alternative.
	
	Code based on bootstrap-tabs.js, updated to:
	- react to option selection instead of tab click
	- disable input fields in non visible tabs
	- disable the possibility to have dropdown menus (no meaning here)
	- act as a regular function instead of as a jQuery plug-in.
	
	@function
	@param {Object} tabs jQuery object that contains the tabular sections
	to initialize. The object may reference more than one element.
	###
	initializeTabs = (tabs) ->
		activate = (element, container) ->
			container.find("> .active").removeClass "active"
			element.addClass "active"

		enableFields = ($target, targetIndex) ->
			
			# Enable all fields in the targeted tab
			$target.find("input, textarea, select").removeAttr "disabled"
			
			# Disable all fields in other tabs
			$target.parent().children(":not([data-idx=" + targetIndex + "])").find("input, textarea, select").attr "disabled", "disabled"

		optionSelected = (e) ->
			$option = $("option:selected", $(this))
			$select = $(this)
			targetIdx = $option.attr("data-idx") or $option.attr("value")
			$target = undefined
			e.preventDefault()
			return  if $option.hasClass("active")
			$target = $(this).parents(".tabbable").eq(0).find(".tab-content [data-idx=" + targetIdx + "]")
			activate $option, $select
			activate $target, $target.parent()
			enableFields $target, targetIdx

		tabClicked = (e) ->
			$a = $("a", $(this))
			$content = $(this).parents(".tabbable").first().find(".tab-content").first()
			targetIdx = $(this).index()
			$target = $content.find("[data-idx=" + targetIdx + "]")
			e.preventDefault()
			activate $(this), $(this).parent()
			activate $target, $target.parent()
			enableFields $target, targetIdx  if $(this).parent().hasClass("jsonform-alternative")

		tabs.each ->
			$(this).delegate "select.nav", "change", optionSelected
			$(this).find("select.nav").each ->
				$(this).val $(this).find(".active").attr("value")
				targetIdx = $(this).find("option:selected").attr("data-idx") or $(this).find("option:selected").attr("value")
				$target = $(this).parents(".tabbable").eq(0).find(".tab-content [data-idx=" + targetIdx + "]")
				enableFields $target, targetIdx

			$(this).delegate "ul.nav li", "click", tabClicked
			$(this).find("ul.nav li.active").click()


	
	# Twitter bootstrap-friendly HTML boilerplate for standard inputs
	jsonform.fieldTemplate = (inner) ->
		"<div class=\"control-group jsonform-error-<%= keydash %> <%= elt.htmlClass ? elt.htmlClass : \"\" %>\"><% if (node.title && !elt.notitle) { %><label class=\"control-label\" for=\"<%= node.id %>\"><%= node.title %></label><% } %><div class=\"controls\"><% if (node.prepend || node.append) { %><div class=\"<% if (node.prepend) { %>input-prepend<% } %><% if (node.append) { %> input-append<% } %>\"><% if (node.prepend) { %><span class=\"add-on\"><%= node.prepend %></span><% } %><% } %>" + inner + "<% if (node.append) { %><span class=\"add-on\"><%= node.append %></span><% } %><% if (node.prepend || node.append) { %></div><% } %><% if (node.description) { %><span class=\"help-inline\"><%= node.description %></span><% } %><span class=\"help-block jsonform-errortext\" style=\"display:none;\"></span></div></div>"

	fileDisplayTemplate = "<% if (value.type==\"image\") { %><img class=\"jsonform-preview\" id=\"jsonformpreview-<%= id %>\" src=\"<%= value.url %>\" /><% } else { %><a href=\"<%= value.url %>\"><%= value.name %></a> (<%= Math.ceil(value.size/1024) %>kB)<% } %><br/>"
	jsonform.elementTypes =
		none:
			template: ""

		root:
			template: "<div><%= children %></div>"

		text:
			template: "<input class=\"input-xlarge xlarge\" type=\"text\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"<%= (node.disabled? \" disabled\" : \"\")%> />"
			fieldtemplate: true
			inputfield: true

		password:
			template: "<input class=\"input-xlarge xlarge\" type=\"password\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"<%= (node.disabled? \" disabled\" : \"\")%> />"
			fieldtemplate: true
			inputfield: true

		color:
			template: "<input class=\"input-xlarge xlarge\" type=\"text\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"<%= (node.disabled? \" disabled\" : \"\")%> />"
			fieldtemplate: true
			inputfield: true
			onInsert: (evt, node) ->
				$(node.el).find("#" + escapeSelector(node.id)).spectrum
					preferredFormat: "hex"
					showInput: true


		textarea:
			template: "<textarea id=\"<%= id %>\" name=\"<%= node.name %>\" style=\"height:<%= elt.height || \"150px\" %>;width:<%= elt.width || \"100%\" %>;\"<%= (node.disabled? \" disabled\" : \"\")%>><%= value %></textarea>"
			fieldtemplate: true
			inputfield: true

		wysihtml5:
			template: "<textarea id=\"<%= id %>\" name=\"<%= node.name %>\" style=\"height:<%= elt.height || \"300px\" %>;width:<%= elt.width || \"100%\" %>;\"><%= value %></textarea>"
			fieldtemplate: true
			inputfield: true
			onInsert: (evt, node) ->
				setup = ->
					
					#protect from double init
					return  if $(node.el).data("wysihtml5")
					$(node.el).data "wysihtml5_loaded", true
					$(node.el).find("#" + escapeSelector(node.id)).wysihtml5
						html: true
						link: true
						"font-styles": true
						image: true


				
				# Is there a setup hook?
				if window.jsonform_wysihtml5_setup
					window.jsonform_wysihtml5_setup setup
					return
				
				# Wait until wysihtml5 is loaded
				itv = window.setInterval(->
					if window.wysihtml5
						window.clearInterval itv
						setup()
				, 1000)

		ace:
			template: "<div id=\"<%= id %>\" style=\"position:relative;height:<%= elt.height || \"300px\" %>;\"><div id=\"<%= id %>__ace\" style=\"width:<%= elt.width || \"100%\" %>;height:<%= elt.height || \"300px\" %>;\"></div><input type=\"hidden\" name=\"<%= node.name %>\" id=\"<%= id %>__hidden\" value=\"<%= escape(value) %>\"/></div>"
			fieldtemplate: true
			inputfield: true
			onInsert: (evt, node) ->
				setup = ->
					formElement = node.formElement or {}
					ace = window.ace
					editor = ace.edit($(node.el).find("#" + escapeSelector(node.id) + "__ace").get(0))
					idSelector = "#" + escapeSelector(node.id) + "__hidden"
					
					# Force editor to use "\n" for new lines, not to bump into ACE "\r" conversion issue
					# (ACE is ok with "\r" on pasting but fails to return "\r" when value is extracted)
					editor.getSession().setNewLineMode "unix"
					editor.renderer.setShowPrintMargin false
					editor.setTheme "ace/theme/" + (formElement.aceTheme or "twilight")
					if formElement.aceMode
						mode = ace.require("ace/mode/" + formElement.aceMode).Mode
						editor.getSession().setMode new mode()
					editor.getSession().setTabSize 2
					
					# Set the contents of the initial manifest file
					editor.getSession().setValue node.value or ""
					
					#TODO this is clearly sub-optimal
					# 'Lazily' bind to the onchange 'ace' event to give
					# priority to user edits
					lazyChanged = _.debounce(->
						$(node.el).find(idSelector).val editor.getSession().getValue()
						$(node.el).find(idSelector).change()
					, 600)
					editor.getSession().on "change", lazyChanged
					editor.on "blur", ->
						$(node.el).find(idSelector).change()
						$(node.el).find(idSelector).trigger "blur"

					editor.on "focus", ->
						$(node.el).find(idSelector).trigger "focus"


				
				# Is there a setup hook?
				if window.jsonform_ace_setup
					window.jsonform_ace_setup setup
					return
				
				# Wait until ACE is loaded
				itv = window.setInterval(->
					if window.ace
						window.clearInterval itv
						setup()
				, 1000)

		checkbox:
			template: "<label class=\"checkbox\"><input type=\"checkbox\" id=\"<%= id %>\" name=\"<%= node.name %>\" value=\"1\" <% if (value) {%>checked<% } %><%= (node.disabled? \" disabled\" : \"\")%> /><span><%= node.inlinetitle || \"\" %></span></label>"
			fieldtemplate: true
			inputfield: true
			getElement: (el) ->
				$(el).parent().get 0

		file:
			template: "<input class=\"input-file\" id=\"<%= id %>\" name=\"<%= node.name %>\" type=\"file\" />"
			fieldtemplate: true
			inputfield: true

		"file-hosted-public":
			template: "<span><% if (value && (value.type||value.url)) { %>" + fileDisplayTemplate + "<% } %><input class=\"input-file\" id=\"_transloadit_<%= id %>\" type=\"file\" name=\"<%= transloaditname %>\" /><input data-transloadit-name=\"_transloadit_<%= transloaditname %>\" type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value='<%= escape(JSON.stringify(node.value)) %>' /></span>"
			fieldtemplate: true
			inputfield: true
			getElement: (el) ->
				$(el).parent().get 0

			onBeforeRender: (data, node) ->
				unless node.ownerTree._transloadit_generic_public_index
					node.ownerTree._transloadit_generic_public_index = 1
				else
					node.ownerTree._transloadit_generic_public_index++
				data.transloaditname = "_transloadit_jsonform_genericupload_public_" + node.ownerTree._transloadit_generic_public_index
				node.ownerTree._transloadit_generic_elts = {}  unless node.ownerTree._transloadit_generic_elts
				node.ownerTree._transloadit_generic_elts[data.transloaditname] = node

			onChange: (evt, elt) ->
				
				# Was transloadit already bound?
				return false  if elt.ownerTree._transloadit_bound
				elt.ownerTree._transloadit_bound = true
				formElt = $(elt.ownerTree.domRoot)
				
				#console.log("Trans config via elt "+elt.id);
				formElt.transloadit
					autoSubmit: false
					wait: true
					onSuccess: (assembly) ->
						
						#console.log("assembly done",assembly);
						if assembly.results[":original"]
							i = 0

							while i < assembly.results[":original"].length
								f = assembly.results[":original"][i]
								$("#" + escapeSelector(elt.ownerTree._transloadit_generic_elts[f.field].id), formElt).val JSON.stringify(f)
								i++
						
						#unbind
						elt.ownerTree._transloadit_bound = false
						formElt.unbind "submit.transloadit"
						setTimeout (->
							elt.ownerTree.submit()
						), 10

					
					#debug:false,
					onError: (assembly) ->
						console.log "Assembly error", assembly


			onSubmit: (evt, elt) ->
				return false  if elt.ownerTree._transloadit_bound
				true

		"file-transloadit":
			template: "<span><% if (value && (value.type||value.url)) { %>#{fileDisplayTemplate}<% } %><input class=\"input-file\" id=\"_transloadit_<%= id %>\" type=\"file\" name=\"_transloadit_<%= node.name %>\" /><input type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value='<%= escape(JSON.stringify(node.value)) %>' /></span>"
			fieldtemplate: true
			inputfield: true
			getElement: (el) ->
				$(el).parent().get 0

			onChange: (evt, elt) ->
				
				# Was transloadit already bound?
				return false  if elt.ownerTree._transloadit_bound
				elt.ownerTree._transloadit_bound = true
				formElt = $(elt.ownerTree.domRoot)
				
				#console.log("Trans config via elt "+elt.id);
				formElt.transloadit
					autoSubmit: false
					wait: true
					onSuccess: (assembly) ->
						
						#console.log("assembly done",assembly);
						if assembly.results[":original"]
							i = 0

							while i < assembly.results[":original"].length
								f = assembly.results[":original"][i]
								$("input[name='" + f.field.replace(/^_transloadit_/, "") + "']", formElt).val JSON.stringify(f)
								i++
						
						#unbind
						elt.ownerTree._transloadit_bound = false
						formElt.unbind "submit.transloadit"
						setTimeout (->
							elt.ownerTree.submit()
						), 10

					
					#debug:false,
					onError: (assembly) ->
						console.log "Assembly error", assembly


			onSubmit: (evt, elt) ->
				return false  if elt.ownerTree._transloadit_bound
				true

		select:
			template: "<select name=\"<%= node.name %>\" id=\"<%= id %>\" <%= (node.disabled? \" disabled\" : \"\")%>> <% _.each(node.options, function(key, val) { if(key instanceof Object) { if (value === key.value) { %> <option selected value=\"<%= key.value %>\"><%= key.title %></option> <% } else { %> <option value=\"<%= key.value %>\"><%= key.title %></option> <% }} else { if (value === key) { %> <option selected value=\"<%= key %>\"><%= key %></option> <% } else { %><option value=\"<%= key %>\"><%= key %></option> <% }}}); %> </select>"
			fieldtemplate: true
			inputfield: true

		imageselect:
			template: "<div><input type=\"hidden\" name=\"<%= node.name %>\" id=\"<%= node.id %>\" value=\"<%= value %>\" /><div class=\"dropdown\"><a class=\"btn<% if (buttonClass && node.value) { %> <%= buttonClass %><% } %>\" data-toggle=\"dropdown\" href=\"#\"<% if (node.value) { %> style=\"max-width:<%= width %>px;max-height:<%= height %>px\"<% } %>><% if (node.value) { %><img src=\"<% if (!node.value.match(/^https?:/)) { %><%= prefix %><% } %><%= node.value %><%= suffix %>\" alt=\"\" /><% } else { %><%= buttonTitle %><% } %></a><div class=\"dropdown-menu navbar\" id=\"<%= node.id %>_dropdown\"><div><% _.each(node.options, function(key, idx) { if ((idx > 0) && ((idx % columns) === 0)) { %></div><div><% } %><a class=\"btn<% if (buttonClass) { %> <%= buttonClass %><% } %>\" style=\"max-width:<%= width %>px;max-height:<%= height %>px\"><% if (key instanceof Object) { %><img src=\"<% if (!key.value.match(/^https?:/)) { %><%= prefix %><% } %><%= key.value %><%= suffix %>\" alt=\"<%= key.title %>\" /></a><% } else { %><img src=\"<% if (!key.match(/^https?:/)) { %><%= prefix %><% } %><%= key %><%= suffix %>\" alt=\"\" /><% } %></a> <% }); %></div><div class=\"pagination-right\"><a class=\"btn\">Reset</a></div></div></div></div>"
			fieldtemplate: true
			inputfield: true
			onBeforeRender: (data, node) ->
				elt = node.formElement or {}
				nbRows = null
				maxColumns = elt.imageSelectorColumns or 5
				data.buttonTitle = elt.imageSelectorTitle or "Select..."
				data.prefix = elt.imagePrefix or ""
				data.suffix = elt.imageSuffix or ""
				data.width = elt.imageWidth or 32
				data.height = elt.imageHeight or 32
				data.buttonClass = elt.imageButtonClass or false
				if node.options.length > maxColumns
					nbRows = Math.ceil(node.options.length / maxColumns)
					data.columns = Math.ceil(node.options.length / nbRows)
				else
					data.columns = maxColumns

			getElement: (el) ->
				$(el).parent().get 0

			onInsert: (evt, node) ->
				$(node.el).on "click", ".dropdown-menu a", (evt) ->
					evt.preventDefault()
					evt.stopPropagation()
					img = (if (evt.target.nodeName.toLowerCase() is "img") then $(evt.target) else $(evt.target).find("img"))
					value = img.attr("src")
					elt = node.formElement or {}
					prefix = elt.imagePrefix or ""
					suffix = elt.imageSuffix or ""
					width = elt.imageWidth or 32
					height = elt.imageHeight or 32
					if value
						value = value.substring(prefix.length)  if value.indexOf(prefix) is 0
						value = value.substring(0, value.length - suffix.length)
						$(node.el).find("input").attr "value", value
						$(node.el).find("a[data-toggle=\"dropdown\"]").addClass(elt.imageButtonClass).attr("style", "max-width:" + width + "px;max-height:" + height + "px").html "<img src=\"" + ((if not value.match(/^https?:/) then prefix else "")) + value + suffix + "\" alt=\"\" />"
					else
						$(node.el).find("input").attr "value", ""
						$(node.el).find("a[data-toggle=\"dropdown\"]").removeClass(elt.imageButtonClass).removeAttr("style").html elt.imageSelectorTitle or "Select..."


		radios:
			template: "<div id=\"<%= node.id %>\"><% _.each(node.options, function(key, val) { %><label class=\"radio\"><input type=\"radio\" <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked=\"checked\" <% } %> name=\"<%= node.name %>\" value=\"<%= (key instanceof Object ? key.value : key) %>\"<%= (node.disabled? \" disabled\" : \"\")%>/><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>"
			fieldtemplate: true
			inputfield: true

		radiobuttons:
			template: "<div id=\"<%= node.id %>\"><% _.each(node.options, function(key, val) { %><label class=\"radio btn\"><input type=\"radio\" style=\"position:absolute;left:-9999px;\" <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked=\"checked\" <% } %> name=\"<%= node.name %>\" value=\"<%= (key instanceof Object ? key.value : key) %>\" /><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>"
			fieldtempate: true
			inputfield: true
			onInsert: (evt, node) ->
				activeClass = "active"
				elt = node.formElement or {}
				activeClass += " " + elt.activeClass  if elt.activeClass
				$(node.el).find("label").on "click", ->
					$(this).parent().find("label").removeClass activeClass
					$(this).addClass activeClass


		checkboxes:
			template: "<div><%= choiceshtml %></div>"
			fieldtemplate: true
			inputfield: true
			onBeforeRender: (data, node) ->
				
				# Build up choices from the enumeration list
				choices = null
				choiceshtml = null
				template = "<label class=\"checkbox\"><input type=\"checkbox\" <% if (value) { %> checked=\"checked\" <% } %> name=\"<%= name %>\" value=\"1\"<%= (node.disabled? \" disabled\" : \"\")%>><span><%= title %></span></label>"
				return  if not node or not node.schemaElement or not node.schemaElement.items
				choices = node.schemaElement.items["enum"] or node.schemaElement.items[0]["enum"]
				return  unless choices
				choiceshtml = ""
				_.each choices, (choice, idx) ->
					choiceshtml += _.template(template,
						name: node.key + "[" + idx + "]"
						value: _.include(node.value, choice)
						title: (if node.formElement.titleMap then node.formElement.titleMap[choice] else choice)
						node: node
					, fieldTemplateSettings)

				data.choiceshtml = choiceshtml

		array:
			template: "<div id=\"<%= id %>\"><ul class=\"_jsonform-array-ul\" style=\"list-style-type:none;\"><%= children %></ul><span class=\"_jsonform-array-buttons\"><a href=\"#\" class=\"btn _jsonform-array-addmore\"><i class=\"icon-plus-sign\" title=\"Add new\"></i></a> <a href=\"#\" class=\"btn _jsonform-array-deletelast\"><i class=\"icon-minus-sign\" title=\"Delete last\"></i></a></span></div>"
			fieldtemplate: true
			array: true
			childTemplate: (inner) ->
				if $("").sortable
					
					# Insert a "draggable" icon
					# floating to the left of the main element
					"<li data-idx=\"<%= node.childPos %>\"><span class=\"draggable line\"><i class=\"icon-list\" title=\"Move item\"></i></span>" + inner + "</li>"
				else
					"<li data-idx=\"<%= node.childPos %>\">" + inner + "</li>"

			onInsert: (evt, node) ->
				$nodeid = $(node.el).find("#" + escapeSelector(node.id))
				boundaries = node.getArrayBoundaries()
				
				# Switch two nodes in an array
				moveNodeTo = (fromIdx, toIdx) ->
					
					# Note "switchValuesWith" extracts values from the DOM since field
					# values are not synchronized with the tree data structure, so calls
					# to render are needed at each step to force values down to the DOM
					# before next move.
					# TODO: synchronize field values and data structure completely and
					# call render only once to improve efficiency.
					return  if fromIdx is toIdx
					incr = (if (fromIdx < toIdx) then 1 else -1)
					i = 0
					parentEl = $("> ul", $nodeid)
					i = fromIdx
					while i isnt toIdx
						node.children[i].switchValuesWith node.children[i + incr]
						node.children[i].render parentEl.get(0)
						node.children[i + incr].render parentEl.get(0)
						i += incr
					
					# No simple way to prevent DOM reordering with jQuery UI Sortable,
					# so we're going to need to move sorted DOM elements back to their
					# origin position in the DOM ourselves (we switched values but not
					# DOM elements)
					fromEl = $(node.children[fromIdx].el)
					toEl = $(node.children[toIdx].el)
					fromEl.detach()
					toEl.detach()
					if fromIdx < toIdx
						if fromIdx is 0
							parentEl.prepend fromEl
						else
							$(node.children[fromIdx - 1].el).after fromEl
						$(node.children[toIdx - 1].el).after toEl
					else
						if toIdx is 0
							parentEl.prepend toEl
						else
							$(node.children[toIdx - 1].el).after toEl
						$(node.children[fromIdx - 1].el).after fromEl

				$("> span > a._jsonform-array-addmore", $nodeid).click (evt) ->
					evt.preventDefault()
					evt.stopPropagation()
					idx = node.children.length
					if boundaries.maxItems >= 0
						$("> span > a._jsonform-array-addmore", $nodeid).addClass "disabled"  if node.children.length > boundaries.maxItems - 2
						return false  if node.children.length > boundaries.maxItems - 1
					node.insertArrayItem idx, $("> ul", $nodeid).get(0)
					$("> span > a._jsonform-array-deletelast", $nodeid).removeClass "disabled"  if boundaries.minItems > 0 and node.children.length > boundaries.minItems - 1

				
				#Simulate Users click to setup the form with its minItems
				curItems = $("> ul > li", $nodeid).length
				if boundaries.minItems >= 0 and curItems < boundaries.minItems
					i = 0

					while i < (boundaries.minItems - 1) and ($("> ul > li", $nodeid).length < boundaries.minItems)
						
						#console.log('Calling click: ',$nodeid);
						#$('> span > a._jsonform-array-addmore', $nodeid).click();
						node.insertArrayItem curItems, $("> ul", $nodeid).get(0)
						i++
					$("> span > a._jsonform-array-deletelast", $nodeid).addClass "disabled"
				$("> span > a._jsonform-array-deletelast", $nodeid).click (evt) ->
					idx = node.children.length - 1
					evt.preventDefault()
					evt.stopPropagation()
					if boundaries.minItems > 0
						$("> span > a._jsonform-array-deletelast", $nodeid).addClass "disabled"  if node.children.length < boundaries.minItems + 2
						return false  if node.children.length <= boundaries.minItems
					node.deleteArrayItem idx
					$("> span > a._jsonform-array-addmore", $nodeid).removeClass "disabled"  if boundaries.maxItems >= 0 and idx <= boundaries.maxItems - 1

				if $(node.el).sortable
					$("> ul", $nodeid).sortable()
					$("> ul", $nodeid).bind "sortstop", (event, ui) ->
						idx = $(ui.item).data("idx")
						newIdx = $(ui.item).index()
						moveNodeTo idx, newIdx


		tabarray:
			template: "<div id=\"<%= id %>\"><div class=\"tabbable tabs-left\"><ul class=\"nav nav-tabs\"><%= tabs %></ul><div class=\"tab-content\"><%= children %></div></div><a href=\"#\" class=\"btn _jsonform-array-addmore\"><i class=\"icon-plus-sign\" title=\"Add new\"></i></a> <a href=\"#\" class=\"btn _jsonform-array-deleteitem\"><i class=\"icon-minus-sign\" title=\"Delete item\"></i></a></div>"
			fieldtemplate: true
			array: true
			childTemplate: (inner) ->
				"<div data-idx=\"<%= node.childPos %>\" class=\"tab-pane\">" + inner + "</div>"

			onBeforeRender: (data, node) ->
				
				# Generate the initial 'tabs' from the children
				tabs = ""
				_.each node.children, (child, idx) ->
					title = child.legend or child.title or ("Item " + (idx + 1))
					tabs += "<li data-idx=\"" + idx + "\"" + ((if (idx is 0) then " class=\"active\"" else "")) + "><a class=\"draggable tab\" data-toggle=\"tab\">" + escapeHTML(title) + "</a></li>"

				data.tabs = tabs

			onInsert: (evt, node) ->
				$nodeid = $(node.el).find("#" + escapeSelector(node.id))
				boundaries = node.getArrayBoundaries()
				moveNodeTo = (fromIdx, toIdx) ->
					
					# Note "switchValuesWith" extracts values from the DOM since field
					# values are not synchronized with the tree data structure, so calls
					# to render are needed at each step to force values down to the DOM
					# before next move.
					# TODO: synchronize field values and data structure completely and
					# call render only once to improve efficiency.
					return  if fromIdx is toIdx
					incr = (if (fromIdx < toIdx) then 1 else -1)
					i = 0
					tabEl = $("> .tabbable > .tab-content", $nodeid).get(0)
					i = fromIdx
					while i isnt toIdx
						node.children[i].switchValuesWith node.children[i + incr]
						node.children[i].render tabEl
						node.children[i + incr].render tabEl
						i += incr

				
				# Refreshes the list of tabs
				updateTabs = (selIdx) ->
					tabs = ""
					activateFirstTab = false
					if selIdx is `undefined`
						selIdx = $("> .tabbable > .nav-tabs .active", $nodeid).data("idx")
						if selIdx
							selIdx = parseInt(selIdx, 10)
						else
							activateFirstTab = true
							selIdx = 0
					selIdx = node.children.length - 1  if selIdx >= node.children.length
					_.each node.children, (child, idx) ->
						title = child.legend or child.title or ("Item " + (idx + 1))
						tabs += "<li data-idx=\"" + idx + "\"><a class=\"draggable tab\" data-toggle=\"tab\">" + escapeHTML(title) + "</a></li>"

					$("> .tabbable > .nav-tabs", $nodeid).html tabs
					$("> .tabbable > .nav-tabs [data-idx=\"0\"]", $nodeid).addClass "active"  if activateFirstTab
					$("> .tabbable > .nav-tabs [data-toggle=\"tab\"]", $nodeid).eq(selIdx).click()

				$("> a._jsonform-array-deleteitem", $nodeid).click (evt) ->
					idx = $("> .tabbable > .nav-tabs .active", $nodeid).data("idx")
					evt.preventDefault()
					evt.stopPropagation()
					if boundaries.minItems > 0
						$("> a._jsonform-array-deleteitem", $nodeid).addClass "disabled"  if node.children.length < boundaries.minItems + 1
						return false  if node.children.length < boundaries.minItems
					node.deleteArrayItem idx
					updateTabs()
					$("> a._jsonform-array-deleteitem", $nodeid).addClass "disabled"  if node.children.length < boundaries.minItems + 1
					$("> a._jsonform-array-addmore", $nodeid).removeClass "disabled"  if boundaries.maxItems >= 0 and node.children.length <= boundaries.maxItems

				$("> a._jsonform-array-addmore", $nodeid).click (evt) ->
					idx = node.children.length
					if boundaries.maxItems >= 0
						$("> a._jsonform-array-addmore", $nodeid).addClass "disabled"  if node.children.length > boundaries.maxItems - 2
						return false  if node.children.length > boundaries.maxItems - 1
					evt.preventDefault()
					evt.stopPropagation()
					node.insertArrayItem idx, $("> .tabbable > .tab-content", $nodeid).get(0)
					updateTabs idx
					$("> a._jsonform-array-deleteitem", $nodeid).removeClass "disabled"  if boundaries.minItems > 0 and idx > boundaries.minItems - 1

				$(node.el).on "legendUpdated", (evt) ->
					updateTabs()
					evt.preventDefault()
					evt.stopPropagation()

				if $(node.el).sortable
					$("> .tabbable > .nav-tabs", $nodeid).sortable
						containment: node.el
						tolerance: "pointer"

					$("> .tabbable > .nav-tabs", $nodeid).bind "sortstop", (event, ui) ->
						idx = $(ui.item).data("idx")
						newIdx = $(ui.item).index()
						moveNodeTo idx, newIdx
						updateTabs newIdx

				
				#Simulate Users click to setup the form with its minItems
				if boundaries.minItems >= 0
					i = 0

					while i < (boundaries.minItems - 1)
						$("> a._jsonform-array-addmore", $nodeid).click()
						i++
					$("> a._jsonform-array-deleteitem", $nodeid).addClass "disabled"
					updateTabs()
				$("> a._jsonform-array-addmore", $nodeid).addClass "disabled"  if (boundaries.maxItems >= 0) and (node.children.length >= boundaries.maxItems)
				$("> a._jsonform-array-deleteitem", $nodeid).addClass "disabled"  if (boundaries.minItems >= 0) and (node.children.length <= boundaries.minItems)

		help:
			template: "<span class=\"help-block\" style=\"padding-top:5px\"><%= elt.helpvalue %></span>"
			fieldtemplate: true

		msg:
			template: "<%= elt.msg %>"

		fieldset:
			template: "<fieldset class=\"control-group jsonform-error-<%= keydash %> <% if (elt.expandable) { %>expandable<% } %> <%= elt.htmlClass?elt.htmlClass:\"\" %>\" <% if (id) { %> id=\"<%= id %>\"<% } %>><% if (node.title || node.legend) { %><legend><%= node.title || node.legend %></legend><% } %><% if (elt.expandable) { %><div class=\"control-group\"><% } %><%= children %><% if (elt.expandable) { %></div><% } %></fieldset>"

		advancedfieldset:
			template: "<fieldset<% if (id) { %> id=\"<%= id %>\"<% } %> class=\"expandable <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><legend>Advanced options</legend><div class=\"control-group\"><%= children %></div></fieldset>"

		authfieldset:
			template: "<fieldset<% if (id) { %> id=\"<%= id %>\"<% } %> class=\"expandable <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><legend>Authentication settings</legend><div class=\"control-group\"><%= children %></div></fieldset>"

		submit:
			template: "<input type=\"submit\" <% if (id) { %> id=\"<%= id %>\" <% } %> class=\"btn btn-primary <%= elt.htmlClass?elt.htmlClass:\"\" %>\" value=\"<%= value || node.title %>\"<%= (node.disabled? \" disabled\" : \"\")%>/>"

		button:
			template: " <button <% if (id) { %> id=\"<%= id %>\" <% } %> class=\"btn <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><%= node.title %></button> "

		actions:
			template: "<div class=\"form-actions <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><%= children %></div>"

		hidden:
			template: "<input type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" />"
			inputfield: true

		selectfieldset:
			template: "<fieldset class=\"tab-container <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><% if (node.legend) { %><legend><%= node.legend %></legend><% } %><% if (node.formElement.key) { %><input type=\"hidden\" id=\"<%= node.id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" /><% } else { %><a id=\"<%= node.id %>\"></a><% } %><div class=\"tabbable\"><div class=\"control-group<%= node.formElement.hideMenu ? \" hide\" : \"\" %>\"><% if (node.title && !elt.notitle) { %><label class=\"control-label\" for=\"<%= node.id %>\"><%= node.title %></label><% } %><div class=\"controls\"><%= tabs %></div></div><div class=\"tab-content\"><%= children %></div></div></fieldset>"
			inputfield: true
			getElement: (el) ->
				$(el).parent().get 0

			childTemplate: (inner) ->
				"<div data-idx=\"<%= node.childPos %>\" class=\"tab-pane<% if (node.active) { %> active<% } %>\">" + inner + "</div>"

			onBeforeRender: (data, node) ->
				
				# Before rendering, this function ensures that:
				# 1. direct children have IDs (used to show/hide the tabs contents)
				# 2. the tab to active is flagged accordingly. The active tab is
				# the first one, except if form values are available, in which case
				# it's the first tab for which there is some value available (or back
				# to the first one if there are none)
				# 3. the HTML of the select field used to select tabs is exposed in the
				# HTML template data as "tabs"
				children = null
				choices = []
				choices = node.schemaElement["enum"] or []  if node.schemaElement
				if node.options
					children = _.map(node.options, (option, idx) ->
						child = node.children[idx]
						if option instanceof Object
							option = _.extend(
								node: child
							, option)
							option.title = option.title or child.legend or child.title or ("Option " + (child.childPos + 1))
							option.value = option.value or choices[idx] or idx
							option
						else
							title: option
							value: choices[child.childPos] or child.childPos
							node: child
					)
				else
					children = _.map(node.children, (child, idx) ->
						title: child.legend or child.title or ("Option " + (child.childPos + 1))
						value: choices[child.childPos] or child.childPos
						node: child
					)
				activeChild = null
				if data.value
					activeChild = _.find(children, (child) ->
						child.value is node.value
					)
				unless activeChild
					activeChild = _.find(children, (child) ->
						child.node.hasNonDefaultValue()
					)
				activeChild = children[0]  unless activeChild
				activeChild.node.active = true
				data.value = activeChild.value
				elt = node.formElement
				tabs = "<select class=\"nav\"" + ((if node.disabled then " disabled" else "")) + ">"
				_.each children, (child, idx) ->
					tabs += "<option data-idx=\"" + idx + "\" value=\"" + child.value + "\"" + ((if child.node.active then " class=\"active\"" else "")) + ">" + escapeHTML(child.title) + "</option>"

				tabs += "</select>"
				data.tabs = tabs
				data

			onInsert: (evt, node) ->
				$(node.el).find("select.nav").first().on "change", (evt) ->
					$option = $(this).find("option:selected")
					$(node.el).find("input[type=\"hidden\"]").first().val $option.attr("value")


		optionfieldset:
			template: "<div<% if (node.id) { %> id=\"<%= node.id %>\"<% } %>><%= children %></div>"

		section:
			template: "<div<% if (node.id) { %> id=\"<%= node.id %>\"<% } %>><%= children %></div>"

		
		###
		A "questions" field renders a series of question fields and binds the
		result to the value of a schema key.
		###
		questions:
			template: "<div><input type=\"hidden\" id=\"<%= node.id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" /><%= children %></div>"
			fieldtempate: true
			inputfield: true
			getElement: (el) ->
				$(el).parent().get 0

			onInsert: (evt, node) ->
				return  if not node.children or (node.children.length is 0)
				_.each node.children, (child) ->
					$(child.el).hide()

				$(node.children[0].el).show()

		
		###
		A "question" field lets user choose a response among possible choices.
		The field is not associated with any schema key. A question should be
		part of a "questions" field that binds a series of questions to a
		schema key.
		###
		question:
			template: "<div id=\"<%= node.id %>\"><% _.each(node.options, function(key, val) { %><label class=\"radio<%= (node.formElement.optionsType === \"radiobuttons\") ? \" btn\" : \"\" %><%= ((key instanceof Object && key.htmlClass) ? \" \" + key.htmlClass : \"\") %>\"><input type=\"radio\" <% if (node.formElement.optionsType === \"radiobuttons\") { %> style=\"position:absolute;left:-9999px;\" <% } %>name=\"<%= node.id %>\" value=\"<%= val %>\"<%= (node.disabled? \" disabled\" : \"\")%>/><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>"
			fieldtemplate: true
			onInsert: (evt, node) ->
				activeClass = "active"
				elt = node.formElement or {}
				activeClass += " " + elt.activeClass  if elt.activeClass
				
				# Bind to change events on radio buttons
				$(node.el).find("input[type=\"radio\"]").on "change", (evt) ->
					questionNode = null
					option = node.options[$(this).val()]
					return  if not node.parentNode or not node.parentNode.el
					$(this).parent().parent().find("label").removeClass activeClass
					$(this).parent().addClass activeClass
					$(node.el).nextAll().hide()
					$(node.el).nextAll().find("input[type=\"radio\"]").prop "checked", false
					
					# Execute possible actions (set key value, form submission, open link,
					# move on to next question)
					
					# Set the key of the 'Questions' parent
					$(node.parentNode.el).find("input[type=\"hidden\"]").val option.value  if option.value
					if option.next
						questionNode = _.find(node.parentNode.children, (child) ->
							child.formElement and (child.formElement.qid is option.next)
						)
						$(questionNode.el).show()
						$(questionNode.el).nextAll().hide()
						$(questionNode.el).nextAll().find("input[type=\"radio\"]").prop "checked", false
					if option.href
						if option.target
							window.open option.href, option.target
						else
							window.location = option.href
					if option.submit
						setTimeout (->
							node.ownerTree.submit()
						), 0


	
	#
	#Legacy elements:
	#
	#'file-jquery-multiple': jsonform.defaultFieldTemplate('<div id="<%= id %>"><div class="fileupload-buttonbar"><label class="fileinput-button"><span>Add files...</span><input type="file" name="<%= node.name %>" multiple></label><button type="submit" class="start">Start upload</button><button type="reset" class="cancel">Cancel upload</button><button type="button" class="delete">Delete files</button></div><div class="fileupload-content"><table class="files"></table><div class="fileupload-progressbar"></div></div></div>'),
	#
	
	#Allow to access subproperties by splitting "."
	###
	Retrieves the key identified by a path selector in the structured object.
	
	Levels in the path are separated by a dot. Array items are marked
	with [x]. For instance:
	foo.bar[3].baz
	
	@function
	@param {Object} obj Structured object to parse
	@param {String} key Path to the key to retrieve
	@param {boolean} ignoreArrays True to use first element in an array when
	stucked on a property. This parameter is basically only useful when
	parsing a JSON schema for which the "items" property may either be an
	object or an array with one object (only one because JSON form does not
	support mix of items for arrays).
	@return {Object} The key's value.
	###
	jsonform.util.getObjKey = (obj, key, ignoreArrays) ->
		innerobj = obj
		keyparts = key.split(".")
		subkey = null
		arrayMatch = null
		i = 0

		while i < keyparts.length
			return null  if (innerobj is null) or (typeof innerobj isnt "object")
			subkey = keyparts[i]
			arrayMatch = subkey.match(reArraySingle)
			if arrayMatch
				
				# Subkey is part of an array
				subkey = subkey.replace(reArraySingle, "")
				return null  unless _.isArray(innerobj[subkey])
				innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)]
			else if ignoreArrays and not innerobj[subkey] and _.isArray(innerobj) and innerobj[0]
				innerobj = innerobj[0][subkey]
			else
				innerobj = innerobj[subkey]
			i++
		if ignoreArrays and _.isArray(innerobj) and innerobj[0]
			innerobj[0]
		else
			innerobj

	
	###
	Sets the key identified by a path selector to the given value.
	
	Levels in the path are separated by a dot. Array items are marked
	with [x]. For instance:
	foo.bar[3].baz
	
	The hierarchy is automatically created if it does not exist yet.
	
	@function
	@param {Object} obj The object to build
	@param {String} key The path to the key to set where each level
	is separated by a dot, and array items are flagged with [x].
	@param {Object} value The value to set, may be of any type.
	###
	jsonform.util.setObjKey = (obj, key, value) ->
		innerobj = obj
		keyparts = key.split(".")
		subkey = null
		arrayMatch = null
		i = 0

		while i < keyparts.length - 1
			subkey = keyparts[i]
			arrayMatch = subkey.match(reArraySingle)
			if arrayMatch
				
				# Subkey is part of an array
				subkey = subkey.replace(reArraySingle, "")
				innerobj[subkey] = []  unless _.isArray(innerobj[subkey])
				innerobj[subkey][parseInt(arrayMatch[1], 10)] = {}  if (typeof innerobj[subkey][parseInt(arrayMatch[1], 10)] isnt "object") or (innerobj[subkey][parseInt(arrayMatch[1], 10)] is null)
				innerobj = innerobj[subkey][parseInt(arrayMatch[1], 10)]
			else
				
				# "Normal" subkey
				innerobj[subkey] = {}  if (typeof innerobj[subkey] isnt "object") or (innerobj[subkey] is null)
				innerobj = innerobj[subkey]
			i++
		
		# Set the final value
		subkey = keyparts[keyparts.length - 1]
		arrayMatch = subkey.match(reArraySingle)
		if arrayMatch
			subkey = subkey.replace(reArraySingle, "")
			innerobj[subkey] = []  unless _.isArray(innerobj[subkey])
			innerobj[subkey][parseInt(arrayMatch[1], 10)] = value
		else
			innerobj[subkey] = value

	
	###
	Retrieves the key definition from the given schema.
	
	The key is identified by the path that leads to the key in the
	structured object that the schema would generate. Each level is
	separated by a '.'. Array levels are marked with []. For instance:
	foo.bar[].baz
	... to retrieve the definition of the key at the following location
	in the JSON schema (using a dotted path notation):
	foo.properties.bar.items.properties.baz
	
	@function
	@param {Object} schema The JSON schema to retrieve the key from
	@param {String} key The path to the key, each level being separated
	by a dot and array items being flagged with [].
	@return {Object} The key definition in the schema, null if not found.
	###
	getSchemaKey = (schema, key) ->
		schemaKey = key.replace(/\./g, ".properties.").replace(/\[[0-9]*\](\.|$)/g, ".items$1")
		jsonform.util.getObjKey schema, schemaKey, true

	
	###
	Truncates the key path to the requested depth.
	
	For instance, if the key path is:
	foo.bar[].baz.toto[].truc[].bidule
	and the requested depth is 1, the returned key will be:
	foo.bar[].baz.toto
	
	Note the function includes the path up to the next depth level.
	
	@function
	@param {String} key The path to the key in the schema, each level being
	separated by a dot and array items being flagged with [].
	@param {Number} depth The array depth
	@return {String} The path to the key truncated to the given depth.
	###
	truncateToArrayDepth = (key, arrayDepth) ->
		depth = 0
		pos = 0
		return null  unless key
		if arrayDepth > 0
			while depth < arrayDepth
				pos = key.indexOf("[]", pos)
				
				# Key path is not "deep" enough, simply return the full key
				return key  if pos is -1
				pos = pos + 2
				depth += 1
		
		# Move one step further to the right without including the final []
		pos = key.indexOf("[]", pos)
		if pos is -1
			key
		else
			key.substring 0, pos

	
	###
	Applies the array path to the key path.
	
	For instance, if the key path is:
	foo.bar[].baz.toto[].truc[].bidule
	and the arrayPath [4, 2], the returned key will be:
	foo.bar[4].baz.toto[2].truc[].bidule
	
	@function
	@param {String} key The path to the key in the schema, each level being
	separated by a dot and array items being flagged with [].
	@param {Array(Number)} arrayPath The array path to apply, e.g. [4, 2]
	@return {String} The path to the key that matches the array path.
	###
	applyArrayPath = (key, arrayPath) ->
		depth = 0
		return null  unless key
		return key  if not arrayPath or (arrayPath.length is 0)
		newKey = key.replace(reArray, (str, p1) ->
			
			# Note this function gets called as many times as there are [x] in the ID,
			# from left to right in the string. The goal is to replace the [x] with
			# the appropriate index in the new array path, if defined.
			newIndex = str
			newIndex = "[" + arrayPath[depth] + "]"  if not _.isUndefined(arrayPath[depth]) and not _.isNull(arrayPath[depth])
			depth += 1
			newIndex
		)
		newKey

	
	###
	Returns the initial value that a field identified by its key
	should take.
	
	The "initial" value is defined as:
	1. the previously submitted value if already submitted
	2. the default value defined in the layout of the form
	3. the default value defined in the schema
	
	The "value" returned is intended for rendering purpose,
	meaning that, for fields that define a titleMap property,
	the function returns the label, and not the intrinsic value.
	
	The function handles values that contains template strings,
	e.g. {{values.foo[].bar}} or {{idx}}.
	
	When the form is a string, the function truncates the resulting string
	to meet a potential "maxLength" constraint defined in the schema, using
	"..." to mark the truncation. Note it does not validate the resulting
	string against other constraints (e.g. minLength, pattern) as it would
	be hard to come up with an automated course of action to "fix" the value.
	
	@function
	@param {Object} formObject The JSON Form object
	@param {String} key The generic key path (e.g. foo[].bar.baz[])
	@param {Array(Number)} arrayPath The array path that identifies
	the unique value in the submitted form (e.g. [1, 3])
	@param {Object} tpldata Template data object
	@param {Boolean} usePreviousValues true to use previously submitted values
	if defined.
	###
	getInitialValue = (formObject, key, arrayPath, tpldata, usePreviousValues) ->
		value = null
		
		# Complete template data for template function
		tpldata = tpldata or {}
		tpldata.idx = tpldata.idx or ((if arrayPath then arrayPath[arrayPath.length - 1] else 1))
		tpldata.value = tpldata.value or ""
		tpldata.getValue = tpldata.getValue or (key) ->
			getInitialValue formObject, key, arrayPath, tpldata, usePreviousValues

		
		# Helper function that returns the form element that explicitly
		# references the given key in the schema.
		getFormElement = (elements, key) ->
			formElement = null
			return null  if not elements or not elements.length
			_.each elements, (elt) ->
				return  if formElement
				if elt is key
					formElement = key: elt
					return
				return  if _.isString(elt)
				if elt.key is key
					formElement = elt
				else formElement = getFormElement(elt.items, key)  if elt.items

			formElement

		formElement = getFormElement(formObject.form or [], key)
		schemaElement = getSchemaKey(formObject.schema.properties, key)
		
		# If values were previously submitted, use them directly if defined
		value = jsonform.util.getObjKey(formObject.value, applyArrayPath(key, arrayPath))  if usePreviousValues and formObject.value
		if (typeof value is "undefined") or (value is null)
			if formElement and (typeof formElement["value"] isnt "undefined")
				
				# Extract the definition of the form field associated with
				# the key as it may override the schema's default value
				value = formElement["value"]
			
			# Simply extract the default value from the schema
			else value = schemaElement["default"] or ""  if schemaElement
			
			# This label wants to use the value of another input field.
			# Convert that construct into {{getValue(key)}} for
			# Underscore to call the appropriate function of formData
			# when template gets called (note calling a function is not
			# exactly Mustache-friendly but is supported by Underscore).
			value = value.replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}")  if value and value.indexOf("{{values.") isnt -1
			value = _.template(value, tpldata, valueTemplateSettings)  if value
		
		# Apply titleMap if needed
		value = _.template(formElement.titleMap[value], tpldata, valueTemplateSettings)  if (typeof value isnt "undefined") and (value isnt null) and formElement and formElement.titleMap and formElement.titleMap[value]
		
		# Check maximum length of a string
		
		# Truncate value to maximum length, adding continuation dots
		value = value.substr(0, schemaElement.maxLength - 1) + "..."  if value.length > schemaElement.maxLength  if value and _.isString(value) and schemaElement and schemaElement.maxLength
		if typeof value is "undefined"
			null
		else
			value

	
	###
	Represents a node in the form.
	
	Nodes that have an ID are linked to the corresponding DOM element
	when rendered
	
	Note the form element and the schema elements that gave birth to the
	node may be shared among multiple nodes (in the case of arrays).
	
	@class
	###
	formNode = ->
		
		###
		The node's ID (may not be set)
		###
		@id = null
		
		###
		The node's key path (may not be set)
		###
		@key = null
		
		###
		DOM element associated witht the form element.
		
		The DOM element is set when the form element is rendered.
		###
		@el = null
		
		###
		Link to the form element that describes the node's layout
		(note the form element is shared among nodes in arrays)
		###
		@formElement = null
		
		###
		Link to the schema element that describes the node's value constraints
		(note the schema element is shared among nodes in arrays)
		###
		@schemaElement = null
		
		###
		Pointer to the "view" associated with the node, typically the right
		object in jsonform.elementTypes
		###
		@view = null
		
		###
		Node's subtree (if one is defined)
		###
		@children = []
		
		###
		A pointer to the form tree the node is attached to
		###
		@ownerTree = null
		
		###
		A pointer to the parent node of the node in the tree
		###
		@parentNode = null
		
		###
		Child template for array-like nodes.
		
		The child template gets cloned to create new array items.
		###
		@childTemplate = null
		
		###
		Direct children of array-like containers may use the value of a
		specific input field in their subtree as legend. The link to the
		legend child is kept here and initialized in computeInitialValues
		when a child sets "valueInLegend"
		###
		@legendChild = null
		
		###
		The path of indexes that lead to the current node when the
		form element is not at the root array level.
		
		Note a form element may well be nested element and still be
		at the root array level. That's typically the case for "fieldset"
		elements. An array level only gets created when a form element
		is of type "array" (or a derivated type such as "tabarray").
		
		The array path of a form element linked to the foo[2].bar.baz[3].toto
		element in the submitted values is [2, 3] for instance.
		
		The array path is typically used to compute the right ID for input
		fields. It is also used to update positions when an array item is
		created, moved around or suppressed.
		
		@type {Array(Number)}
		###
		@arrayPath = []
		
		###
		Position of the node in the list of children of its parents
		###
		@childPos = 0

	
	###
	Clones a node
	
	@function
	@param {formNode} New parent node to attach the node to
	@return {formNode} Cloned node
	###
	formNode::clone = (parentNode) ->
		node = new formNode()
		node.arrayPath = _.clone(@arrayPath)
		node.ownerTree = @ownerTree
		node.parentNode = parentNode or @parentNode
		node.formElement = @formElement
		node.schemaElement = @schemaElement
		node.view = @view
		node.children = _.map(@children, (child) ->
			child.clone node
		)
		node.childTemplate = @childTemplate.clone(node)  if @childTemplate
		node

	
	###
	Returns true if the subtree that starts at the current node
	has some non empty value attached to it
	###
	formNode::hasNonDefaultValue = ->
		
		# hidden elements don't count because they could make the wrong selectfieldset element active
		return false  if @formElement and @formElement.type is "hidden"
		return true  if @value and not @defaultValue
		child = _.find(@children, (child) ->
			child.hasNonDefaultValue()
		)
		!!child

	
	###
	Attaches a child node to the current node.
	
	The child node is appended to the end of the list.
	
	@function
	@param {formNode} node The child node to append
	@return {formNode} The inserted node (same as the one given as parameter)
	###
	formNode::appendChild = (node) ->
		node.parentNode = this
		node.childPos = @children.length
		@children.push node
		node

	
	###
	Removes the last child of the node.
	
	@function
	###
	formNode::removeChild = ->
		child = @children[@children.length - 1]
		return  unless child
		
		# Remove the child from the DOM
		$(child.el).remove()
		
		# Remove the child from the array
		@children.pop()

	
	###
	Moves the user entered values set in the current node's subtree to the
	given node's subtree.
	
	The target node must follow the same structure as the current node
	(typically, they should have been generated from the same node template)
	
	The current node MUST be rendered in the DOM.
	
	TODO: when current node is not in the DOM, extract values from formNode.value
	properties, so that the function be available even when current node is not
	in the DOM.
	
	Moving values around allows to insert/remove array items at arbitrary
	positions.
	
	@function
	@param {formNode} node Target node.
	###
	formNode::moveValuesTo = (node) ->
		values = @getFormValues(node.arrayPath)
		node.resetValues()
		node.computeInitialValues values, true

	
	###
	Switches nodes user entered values.
	
	The target node must follow the same structure as the current node
	(typically, they should have been generated from the same node template)
	
	Both nodes MUST be rendered in the DOM.
	
	TODO: update getFormValues to work even if node is not rendered, using
	formNode's "value" property.
	
	@function
	@param {formNode} node Target node
	###
	formNode::switchValuesWith = (node) ->
		values = @getFormValues(node.arrayPath)
		nodeValues = node.getFormValues(@arrayPath)
		node.resetValues()
		node.computeInitialValues values, true
		@resetValues()
		@computeInitialValues nodeValues, true

	
	###
	Resets all DOM values in the node's subtree.
	
	This operation also drops all array item nodes.
	Note values are not reset to their default values, they are rather removed!
	
	@function
	###
	formNode::resetValues = ->
		params = null
		idx = 0
		
		# Reset value
		@value = null
		
		# Propagate the array path from the parent node
		# (adding the position of the child for nodes that are direct
		# children of array-like nodes)
		if @parentNode
			@arrayPath = _.clone(@parentNode.arrayPath)
			@arrayPath.push @childPos  if @parentNode.view and @parentNode.view.array
		else
			@arrayPath = []
		if @view and @view.inputfield
			
			# Simple input field, extract the value from the origin,
			# set the target value and reset the origin value
			params = $(":input", @el).serializeArray()
			_.each params, ((param) ->
				
				# TODO: check this, there may exist corner cases with this approach
				# (with multiple checkboxes for instance)
				$("[name=\"" + escapeSelector(param.name) + "\"]", $(@el)).val ""
			), this
		
		# The current node is an array, drop all children
		else @removeChild()  while @children.length > 0  if @view and @view.array
		
		# Recurse down the tree
		_.each @children, (child) ->
			child.resetValues()


	
	###
	Sets the child template node for the current node.
	
	The child template node is used to create additional children
	in an array-like form element. The template is never rendered.
	
	@function
	@param {formNode} node The child template node to set
	###
	formNode::setChildTemplate = (node) ->
		@childTemplate = node
		node.parentNode = this

	
	###
	Recursively sets values to all nodes of the current subtree
	based on previously submitted values, or based on default
	values when the submitted values are not enough
	
	The function should be called once in the lifetime of a node
	in the tree. It expects its parent's arrayPath to be up to date.
	
	Three cases may arise:
	1. if the form element is a simple input field, the value is
	extracted from previously submitted values of from default values
	defined in the schema.
	2. if the form element is an array-like node, the child template
	is used to create as many children as possible (and at least one).
	3. the function simply recurses down the node's subtree otherwise
	(this happens when the form element is a fieldset-like element).
	
	@function
	@param {Object} values Previously submitted values for the form
	@param {Boolean} ignoreDefaultValues Ignore default values defined in the
	schema when set.
	###
	formNode::computeInitialValues = (values, ignoreDefaultValues) ->
		self = this
		node = null
		nbChildren = 1
		i = 0
		formData = @ownerTree.formDesc.tpldata or {}
		
		# Propagate the array path from the parent node
		# (adding the position of the child for nodes that are direct
		# children of array-like nodes)
		if @parentNode
			@arrayPath = _.clone(@parentNode.arrayPath)
			@arrayPath.push @childPos  if @parentNode.view and @parentNode.view.array
		else
			@arrayPath = []
		
		# Prepare special data param "idx" for templated values
		# (is is the index of the child in its wrapping array, starting
		# at 1 since that's more human-friendly than a zero-based index)
		formData.idx = (if (@arrayPath.length > 0) then @arrayPath[@arrayPath.length - 1] + 1 else @childPos + 1)
		
		# Prepare special data param "value" for templated values
		formData.value = ""
		
		# Prepare special function to compute the value of another field
		formData.getValue = (key) ->
			getInitialValue self.ownerTree.formDesc, key, self.arrayPath, formData, !!values

		if @formElement
			
			# Compute the ID of the field (if needed)
			if @formElement.id
				@id = applyArrayPath(@formElement.id, @arrayPath)
			else if @view and @view.array
				@id = escapeSelector(@ownerTree.formDesc.prefix) + "-elt-counter-" + _.uniqueId()
			else if @parentNode and @parentNode.view and @parentNode.view.array
				
				# Array items need an array to associate the right DOM element
				# to the form node when the parent is rendered.
				@id = escapeSelector(@ownerTree.formDesc.prefix) + "-elt-counter-" + _.uniqueId()
			
			# Buttons do need an id for "onClick" purpose
			else @id = escapeSelector(@ownerTree.formDesc.prefix) + "-elt-counter-" + _.uniqueId()  if (@formElement.type is "button") or (@formElement.type is "selectfieldset") or (@formElement.type is "question") or (@formElement.type is "buttonquestion")
			
			# Compute the actual key (the form element's key is index-free,
			# i.e. it looks like foo[].bar.baz[].truc, so we need to apply
			# the array path of the node to get foo[4].bar.baz[2].truc)
			if @formElement.key
				@key = applyArrayPath(@formElement.key, @arrayPath)
				@keydash = @key.replace(/\./g, "---")
			
			# Same idea for the field's name
			@name = applyArrayPath(@formElement.name, @arrayPath)
			
			# Consider that label values are template values and apply the
			# form's data appropriately (note we also apply the array path
			# although that probably doesn't make much sense for labels...)
			_.each ["title", "legend", "description", "append", "prepend", "inlinetitle", "helpvalue", "value", "disabled"], ((prop) ->
				if _.isString(@formElement[prop])
					if @formElement[prop].indexOf("{{values.") isnt -1
						
						# This label wants to use the value of another input field.
						# Convert that construct into {{jsonform.getValue(key)}} for
						# Underscore to call the appropriate function of formData
						# when template gets called (note calling a function is not
						# exactly Mustache-friendly but is supported by Underscore).
						this[prop] = @formElement[prop].replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}")
					else
						
						# Note applying the array path probably doesn't make any sense,
						# but some geek might want to have a label "foo[].bar[].baz",
						# with the [] replaced by the appropriate array path.
						this[prop] = applyArrayPath(@formElement[prop], @arrayPath)
					this[prop] = _.template(this[prop], formData, valueTemplateSettings)  if this[prop]
				else
					this[prop] = @formElement[prop]
			), this
			
			# Apply templating to options created with "titleMap" as well
			if @formElement.options
				@options = _.map(@formElement.options, (option) ->
					title = null
					if _.isObject(option) and option.title
						
						# See a few lines above for more details about templating
						# preparation here.
						if option.title.indexOf("{{values.") isnt -1
							title = option.title.replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}")
						else
							title = applyArrayPath(option.title, self.arrayPath)
						_.extend {}, option,
							value: ((if (typeof option.value isnt "undefined") then option.value else ""))
							title: _.template(title, formData, valueTemplateSettings)

					else
						option
				)
		if @view and @view.inputfield and @schemaElement
			
			# Case 1: simple input field
			if values
				
				# Form has already been submitted, use former value if defined.
				# Note we won't set the field to its default value otherwise
				# (since the user has already rejected it)
				@value = jsonform.util.getObjKey(values, @key)  if jsonform.util.getObjKey(values, @key)
			else unless ignoreDefaultValues
				
				# No previously submitted form result, use default value
				# defined in the schema if it's available and not already
				# defined in the form element
				if not @value and @schemaElement["default"]
					@value = @schemaElement["default"]
					if _.isString(@value)
						if @value.indexOf("{{values.") isnt -1
							
							# This label wants to use the value of another input field.
							# Convert that construct into {{jsonform.getValue(key)}} for
							# Underscore to call the appropriate function of formData
							# when template gets called (note calling a function is not
							# exactly Mustache-friendly but is supported by Underscore).
							@value = @value.replace(/\{\{values\.([^\}]+)\}\}/g, "{{getValue(\"$1\")}}")
						else
							
							# Note applying the array path probably doesn't make any sense,
							# but some geek might want to have a label "foo[].bar[].baz",
							# with the [] replaced by the appropriate array path.
							@value = applyArrayPath(@value, @arrayPath)
						@value = _.template(@value, formData, valueTemplateSettings)  if @value
					@defaultValue = true
		else if @view and @view.array
			
			# Case 2: array-like node
			nbChildren = 0
			nbChildren = @getPreviousNumberOfItems(values, @arrayPath)  if values
			
			# TODO: use default values at the array level when form has not been
			# submitted before. Note it's not that easy because each value may
			# be a complex structure that needs to be pushed down the subtree.
			# The easiest way is probably to generate a "values" object and
			# compute initial values from that object
			#
			#    else if (this.schemaElement['default']) {
			#      nbChildren = this.schemaElement['default'].length;
			#    }
			#    
			nbChildren = 1  if nbChildren is 0
			i = 0
			while i < nbChildren
				@appendChild @childTemplate.clone()
				i++
		
		# Case 3 and in any case: recurse through the list of children
		_.each @children, (child) ->
			child.computeInitialValues values, ignoreDefaultValues

		
		# If the node's value is to be used as legend for its "container"
		# (typically the array the node belongs to), ensure that the container
		# has a direct link to the node for the corresponding tab.
		if @formElement and @formElement.valueInLegend
			node = this
			while node
				if node.parentNode and node.parentNode.view and node.parentNode.view.array
					node.legendChild = this
					if node.formElement and node.formElement.legend
						node.legend = applyArrayPath(node.formElement.legend, node.arrayPath)
						formData.idx = (if (node.arrayPath.length > 0) then node.arrayPath[node.arrayPath.length - 1] + 1 else node.childPos + 1)
						formData.value = @value or ""
						node.legend = _.template(node.legend, formData, valueTemplateSettings)
						break
				node = node.parentNode

	
	###
	Returns the number of items that the array node should have based on
	previously submitted values.
	
	The whole difficulty is that values may be hidden deep in the subtree
	of the node and may actually target different arrays in the JSON schema.
	
	@function
	@param {Object} values Previously submitted values
	@param {Array(Number)} arrayPath the array path we're interested in
	@return {Number} The number of items in the array
	###
	formNode::getPreviousNumberOfItems = (values, arrayPath) ->
		key = null
		arrayValue = null
		childNumbers = null
		idx = 0
		
		# No previously submitted values, no need to go any further
		return 0  unless values
		if @view.inputfield and @schemaElement
			
			# Case 1: node is a simple input field that links to a key in the schema.
			# The schema key looks typically like:
			#  foo.bar[].baz.toto[].truc[].bidule
			# The goal is to apply the array path and truncate the key to the last
			# array we're interested in, e.g. with an arrayPath [4, 2]:
			#  foo.bar[4].baz.toto[2]
			key = truncateToArrayDepth(@formElement.key, arrayPath.length)
			key = applyArrayPath(key, arrayPath)
			arrayValue = jsonform.util.getObjKey(values, key)
			
			# No key? That means this field had been left empty
			# in previous submit
			return 0  unless arrayValue
			childNumbers = _.map(@children, (child) ->
				child.getPreviousNumberOfItems values, arrayPath
			)
			_.max [_.max(childNumbers) or 0, arrayValue.length]
		else if @view.array
			
			# Case 2: node is an array-like node, look for input fields
			# in its child template
			@childTemplate.getPreviousNumberOfItems values, arrayPath
		else
			
			# Case 3: node is a leaf or a container,
			# recurse through the list of children and return the maximum
			# number of items found in each subtree
			childNumbers = _.map(@children, (child) ->
				child.getPreviousNumberOfItems values, arrayPath
			)
			_.max(childNumbers) or 0

	
	###
	Returns the structured object that corresponds to the form values entered
	by the user for the node's subtree.
	
	The returned object follows the structure of the JSON schema that gave
	birth to the form.
	
	Obviously, the node must have been rendered before that function may
	be called.
	
	@function
	@param {Array(Number)} updateArrayPath Array path to use to pretend that
	the entered values were actually entered for another item in an array
	(this is used to move values around when an item is inserted/removed/moved
	in an array)
	@return {Object} The object that follows the data schema and matches the
	values entered by the user.
	###
	formNode::getFormValues = (updateArrayPath) ->
		
		# The values object that will be returned
		values = {}
		throw new Error("formNode.getFormValues can only be called on nodes that are associated with a DOM element in the tree")  unless @el
		
		# Form fields values
		formArray = $(":input", @el).serializeArray()
		if updateArrayPath
			_.each formArray, (param) ->
				param.name = applyArrayPath(param.name, updateArrayPath)

		
		# The underlying data schema
		formSchema = @ownerTree.formDesc.schema
		i = 0

		while i < formArray.length
			
			# Retrieve the key definition from the data schema
			name = formArray[i].name
			eltSchema = getSchemaKey(formSchema.properties, name)
			arrayMatch = null
			cval = null
			
			# Skip the input field if it's not part of the schema
			continue  unless eltSchema
			
			# Handle multiple checkboxes separately as the idea is to generate
			# an array that contains the list of enumeration items that the user
			# selected.
			if eltSchema._jsonform_checkboxes_as_array
				arrayMatch = name.match(/\[([0-9]*)\]$/)
				if arrayMatch
					name = name.replace(/\[([0-9]*)\]$/, "")
					cval = jsonform.util.getObjKey(values, name) or []
					
					# Value selected, push the corresponding enumeration item
					# to the data result
					cval.push eltSchema["enum"][parseInt(arrayMatch[1], 10)]  if formArray[i].value is "1"
					jsonform.util.setObjKey values, name, cval
					continue
			
			# Type casting
			if eltSchema.type is "boolean"
				if formArray[i].value is "0"
					formArray[i].value = false
				else
					formArray[i].value = !!formArray[i].value
			if (eltSchema.type is "number") or (eltSchema.type is "integer")
				if _.isString(formArray[i].value)
					unless formArray[i].value.length
						formArray[i].value = `undefined`
					else formArray[i].value = Number(formArray[i].value)  unless isNaN(Number(formArray[i].value))
			formArray[i].value = null  if (eltSchema.type is "string") and (formArray[i].value is "") and not eltSchema._jsonform_allowEmpty
			if (eltSchema.type is "object") and _.isString(formArray[i].value) and (formArray[i].value.substring(0, 1) is "{")
				try
					formArray[i].value = JSON.parse(formArray[i].value)
				catch e
					formArray[i].value = {}
			
			#TODO is this due to a serialization bug?
			formArray[i].value = null  if (eltSchema.type is "object") and (formArray[i].value is "null" or formArray[i].value is "")
			jsonform.util.setObjKey values, formArray[i].name, formArray[i].value  if formArray[i].name and (formArray[i].value isnt null)
			i++
		
		# console.log("Form value",values);
		values

	
	###
	Renders the node.
	
	Rendering is done in three steps: HTML generation, DOM element creation
	and insertion, and an enhance step to bind event handlers.
	
	@function
	@param {Node} el The DOM element where the node is to be rendered. The
	node is inserted at the right position based on its "childPos" property.
	###
	formNode::render = (el) ->
		html = @generate()
		@setContent html, el
		@enhance()

	
	###
	Inserts/Updates the HTML content of the node in the DOM.
	
	If the HTML is an update, the new HTML content replaces the old one.
	The new HTML content is not moved around in the DOM in particular.
	
	The HTML is inserted at the right position in its parent's DOM subtree
	otherwise (well, provided there are enough children, but that should always
	be the case).
	
	@function
	@param {string} html The HTML content to render
	@param {Node} parentEl The DOM element that is to contain the DOM node.
	This parameter is optional (the node's parent is used otherwise) and
	is ignored if the node to render is already in the DOM tree.
	###
	formNode::setContent = (html, parentEl) ->
		node = $(html)
		parentNode = parentEl or ((if @parentNode then @parentNode.el else @ownerTree.domRoot))
		nextSibling = null
		if @el
			
			# Replace the contents of the DOM element if the node is already in the tree
			$(@el).replaceWith node
		else
			
			# Insert the node in the DOM if it's not already there
			nextSibling = $(parentNode).children().get(@childPos)
			if nextSibling
				$(nextSibling).before node
			else
				$(parentNode).append node
		
		# Save the link between the form node and the generated HTML
		@el = node
		
		# Update the node's subtree, extracting DOM elements that match the nodes
		# from the generated HTML
		@updateElement @el

	
	###
	Updates the DOM element associated with the node.
	
	Only nodes that have ID are directly associated with a DOM element.
	
	@function
	###
	formNode::updateElement = (domNode) ->
		if @id
			@el = $("#" + escapeSelector(@id), domNode).get(0)
			@el = @view.getElement(@el)  if @view and @view.getElement
			if (@fieldtemplate isnt false) and @view and @view.fieldtemplate
				
				# The field template wraps the element two or three level deep
				# in the DOM tree, depending on whether there is anything prepended
				# or appended to the input field
				@el = $(@el).parent().parent()
				@el = @el.parent()  if @prepend or @prepend
				@el = @el.get(0)
			
			# TODO: the child template may introduce more than one level,
			# so the number of levels introduced should rather be exposed
			# somehow in jsonform.fieldtemplate.
			@el = $(@el).parent().get(0)  if @parentNode and @parentNode.view and @parentNode.view.childTemplate
		_.each @children, (child) ->
			child.updateElement @el or domNode


	
	###
	Generates the view's HTML content for the underlying model.
	
	@function
	###
	formNode::generate = ->
		data =
			id: @id
			keydash: @keydash
			elt: @formElement
			schema: @schemaElement
			node: this
			value: @value or ""
			escape: escapeHTML

		template = null
		html = ""
		
		# Complete the data context if needed
		@ownerTree.formDesc.onBeforeRender data, this  if @ownerTree.formDesc.onBeforeRender
		@view.onBeforeRender data, this  if @view.onBeforeRender
		
		# Use the template that 'onBeforeRender' may have set,
		# falling back to that of the form element otherwise
		if @template
			template = @template
		else if @formElement and @formElement.template
			template = @formElement.template
		else
			template = @view.template
		
		# Wrap the view template in the generic field template
		# (note the strict equality to 'false', needed as we fallback
		# to the view's setting otherwise)
		template = jsonform.fieldTemplate(template)  if (@fieldtemplate isnt false) and (@fieldtemplate or @view.fieldtemplate)
		
		# Wrap the content in the child template of its parent if necessary.
		template = @parentNode.view.childTemplate(template)  if @parentNode and @parentNode.view and @parentNode.view.childTemplate
		
		# Prepare the HTML of the children
		childrenhtml = ""
		_.each @children, (child) ->
			childrenhtml += child.generate()

		data.children = childrenhtml
		
		# Apply the HTML template
		html = _.template(template, data, fieldTemplateSettings)
		html

	
	###
	Enhances the view with additional logic, binding event handlers
	in particular.
	
	The function also runs the "insert" event handler of the view and
	form element if they exist (starting with that of the view)
	
	@function
	###
	formNode::enhance = ->
		node = this
		handlers = null
		handler = null
		formData = _.clone(@ownerTree.formDesc.tpldata) or {}
		if @formElement
			
			# Check the view associated with the node as it may define an "onInsert"
			# event handler to be run right away
			if @view.onInsert
				@view.onInsert
					target: $(@el)
				, this
			handlers = @handlers or @formElement.handlers
			
			# Trigger the "insert" event handler
			handler = @onInsert or @formElement.onInsert
			if handler
				handler
					target: $(@el)
				, this
			if handlers
				_.each handlers, ((handler, onevent) ->
					if onevent is "insert"
						handler
							target: $(@el)
						, this
				), this
			
			# No way to register event handlers if the DOM element is unknown
			# TODO: find some way to register event handlers even when this.el is not set.
			if @el
				
				# Register specific event handlers
				# TODO: Add support for other event handlers
				if @onChange
					$(@el).bind "change", (evt) ->
						node.onChange evt, node

				if @view.onChange
					$(@el).bind "change", (evt) ->
						node.view.onChange evt, node

				if @formElement.onChange
					$(@el).bind "change", (evt) ->
						node.formElement.onChange evt, node

				if @onClick
					$(@el).bind "click", (evt) ->
						node.onClick evt, node

				if @view.onClick
					$(@el).bind "click", (evt) ->
						node.view.onClick evt, node

				if @formElement.onClick
					$(@el).bind "click", (evt) ->
						node.formElement.onClick evt, node

				if @onKeyUp
					$(@el).bind "keyup", (evt) ->
						node.onKeyUp evt, node

				if @view.onKeyUp
					$(@el).bind "keyup", (evt) ->
						node.view.onKeyUp evt, node

				if @formElement.onKeyUp
					$(@el).bind "keyup", (evt) ->
						node.formElement.onKeyUp evt, node

				if handlers
					_.each handlers, ((handler, onevent) ->
						if onevent isnt "insert"
							$(@el).bind onevent, (evt) ->
								handler evt, node

					), this
			
			# Auto-update legend based on the input field that's associated with it
			if @legendChild and @legendChild.formElement
				$(@legendChild.el).bind "keyup", (evt) ->
					if node.formElement and node.formElement.legend and node.parentNode
						node.legend = applyArrayPath(node.formElement.legend, node.arrayPath)
						formData.idx = (if (node.arrayPath.length > 0) then node.arrayPath[node.arrayPath.length - 1] + 1 else node.childPos + 1)
						formData.value = $(evt.target).val()
						node.legend = _.template(node.legend, formData, valueTemplateSettings)
						$(node.parentNode.el).trigger "legendUpdated"

		
		# Recurse down the tree to enhance children
		_.each @children, (child) ->
			child.enhance()


	
	###
	Inserts an item in the array at the requested position and renders the item.
	
	@function
	@param {Number} idx Insertion index
	###
	formNode::insertArrayItem = (idx, domElement) ->
		i = 0
		
		# Insert element at the end of the array if index is not given
		idx = @children.length  if idx is `undefined`
		
		# Create the additional array item at the end of the list,
		# using the item template created when tree was initialized
		# (the call to resetValues ensures that 'arrayPath' is correctly set)
		child = @childTemplate.clone()
		@appendChild child
		child.resetValues()
		
		# To create a blank array item at the requested position,
		# shift values down starting at the requested position
		# one to insert (note we start with the end of the array on purpose)
		i = @children.length - 2
		while i >= idx
			@children[i].moveValuesTo @children[i + 1]
			i--
		
		# Initialize the blank node we've created with default values
		@children[idx].resetValues()
		@children[idx].computeInitialValues()
		
		# Re-render all children that have changed
		i = idx
		while i < @children.length
			@children[i].render domElement
			i++

	
	###
	Remove an item from an array
	
	@function
	@param {Number} idx The index number of the item to remove
	###
	formNode::deleteArrayItem = (idx) ->
		i = 0
		child = null
		
		# Delete last item if no index is given
		idx = @children.length - 1  if idx is `undefined`
		
		# Move values up in the array
		i = idx
		while i < @children.length - 1
			@children[i + 1].moveValuesTo @children[i]
			@children[i].render()
			i++
		
		# Remove the last array item from the DOM tree and from the form tree,
		# except if the item is the last one left, in which case it is simply reset.
		if @children.length > 1
			@removeChild()
		else
			@children[0].resetValues()
			@children[0].computeInitialValues()
			@children[0].render()

	
	###
	Returns the minimum/maximum number of items that an array field
	is allowed to have according to the schema definition of the fields
	it contains.
	
	The function parses the schema definitions of the array items that
	compose the current "array" node and returns the minimum value of
	"maxItems" it encounters as the maximum number of items, and the
	maximum value of "minItems" as the minimum number of items.
	
	The function reports a -1 for either of the boundaries if the schema
	does not put any constraint on the number of elements the current
	array may have of if the current node is not an array.
	
	Note that array boundaries should be defined in the JSON Schema using
	"minItems" and "maxItems". The code also supports "minLength" and
	"maxLength" as a fallback, mostly because it used to by mistake (see #22)
	and because other people could make the same mistake.
	
	@function
	@return {Object} An object with properties "minItems" and "maxItems"
	that reports the corresponding number of items that the array may
	have (value is -1 when there is no constraint for that boundary)
	###
	formNode::getArrayBoundaries = ->
		boundaries =
			minItems: -1
			maxItems: -1

		return boundaries  if not @view or not @view.array
		getNodeBoundaries = (node, initialNode) ->
			schemaKey = null
			boundaries =
				minItems: -1
				maxItems: -1

			initialNode = initialNode or node
			
			# New array level not linked to an array in the schema,
			# so no size constraints
			return boundaries  if node.view and node.view.array and (node isnt initialNode)
			if node.key
				
				# Note the conversion to target the actual array definition in the
				# schema where minItems/maxItems may be defined,
				# e.g. from foo[0].bar[3].baz to foo[].bar
				schemaKey = getSchemaKey(node.ownerTree.formDesc.schema.properties, node.key.replace(/\[[0-9]+\]/g, "[]").replace(/\[\][^\[\]]*$/, ""))
				return boundaries  unless schemaKey
				return (
					minItems: schemaKey.minItems or schemaKey.minLength or -1
					maxItems: schemaKey.maxItems or schemaKey.maxLength or -1
				)
			else
				_.each node.children, (child) ->
					subBoundaries = getNodeBoundaries(child, initialNode)
					if subBoundaries.minItems isnt -1
						if boundaries.minItems isnt -1
							boundaries.minItems = Math.max(boundaries.minItems, subBoundaries.minItems)
						else
							boundaries.minItems = subBoundaries.minItems
					if subBoundaries.maxItems isnt -1
						if boundaries.maxItems isnt -1
							boundaries.maxItems = Math.min(boundaries.maxItems, subBoundaries.maxItems)
						else
							boundaries.maxItems = subBoundaries.maxItems

			boundaries

		getNodeBoundaries this

	
	###
	Form tree class.
	
	Holds the internal representation of the form.
	The tree is always in sync with the rendered form, this allows to parse
	it easily.
	
	@class
	###
	formTree = ->
		@eventhandlers = []
		@root = null
		@formDesc = null

	
	###
	Initializes the form tree structure from the JSONForm object
	
	This function is the main entry point of the JSONForm library.
	
	Initialization steps:
	1. the internal tree structure that matches the JSONForm object
	gets created (call to buildTree)
	2. initial values are computed from previously submitted values
	or from the default values defined in the JSON schema.
	
	When the function returns, the tree is ready to be rendered through
	a call to "render".
	
	@function
	###
	formTree::initialize = (formDesc) ->
		formDesc = formDesc or {}
		
		# Keep a pointer to the initial JSONForm
		# (note clone returns a shallow copy, only first-level is cloned)
		@formDesc = _.clone(formDesc)
		
		# Compute form prefix if no prefix is given.
		@formDesc.prefix = @formDesc.prefix or "jsonform-" + _.uniqueId()
		
		# JSON schema shorthand
		@formDesc.schema = properties: @formDesc.schema  if @formDesc.schema and not @formDesc.schema.properties
		
		# Ensure layout is set
		@formDesc.form = @formDesc.form or ["*",
			type: "actions"
			items: [
				type: "submit"
				value: "Submit"
			]
		]
		@formDesc.form = ((if _.isArray(@formDesc.form) then @formDesc.form else [@formDesc.form]))
		
		# Create the root of the tree
		@root = new formNode()
		@root.ownerTree = this
		@root.view = jsonform.elementTypes["root"]
		
		# Generate the tree from the form description
		@buildTree()
		
		# Compute the values associated with each node
		# (for arrays, the computation actually creates the form nodes)
		@computeInitialValues()

	
	###
	Constructs the tree from the form description.
	
	The function must be called once when the tree is first created.
	
	@function
	###
	formTree::buildTree = ->
		
		# Parse and generate the form structure based on the elements encountered:
		# - '*' means "generate all possible fields using default layout"
		# - a key reference to target a specific data element
		# - a more complex object to generate specific form sections
		_.each @formDesc.form, ((formElement) ->
			if formElement is "*"
				_.each @formDesc.schema.properties, ((element, key) ->
					@root.appendChild @buildFromLayout(key: key)
				), this
			else
				formElement = key: formElement  if _.isString(formElement)
				@root.appendChild @buildFromLayout(formElement)
		), this

	
	###
	Builds the internal form tree representation from the requested layout.
	
	The function is recursive, generating the node children as necessary.
	The function extracts the values from the previously submitted values
	(this.formDesc.value) or from default values defined in the schema.
	
	@function
	@param {Object} formElement JSONForm element to render
	@param {Object} context The parsing context (the array depth in particular)
	@return {Object} The node that matches the element.
	###
	formTree::buildFromLayout = (formElement, context) ->
		schemaElement = null
		node = new formNode()
		view = null
		key = null
		
		# The form element parameter directly comes from the initial
		# JSONForm object. We'll make a shallow copy of it and of its children
		# not to pollute the original object.
		# (note JSON.parse(JSON.stringify()) cannot be used since there may be
		# event handlers in there!)
		formElement = _.clone(formElement)
		if formElement.items
			if _.isArray(formElement.items)
				formElement.items = _.map(formElement.items, _.clone)
			else
				formElement.items = [_.clone(formElement.items)]
		if formElement.key
			
			# The form element is directly linked to an element in the JSON
			# schema. The properties of the form element override those of the
			# element in the JSON schema. Properties from the JSON schema complete
			# those of the form element otherwise.
			
			# Retrieve the element from the JSON schema
			schemaElement = getSchemaKey(@formDesc.schema.properties, formElement.key)
			
			# The JSON Form is invalid!
			throw new Error("The JSONForm object references the schema key \"" + formElement.key + "\" but that key does not exist in the JSON schema")  unless schemaElement
			
			# Schema element has just been found, let's trigger the
			# "onElementSchema" event
			# (tidoust: not sure what the use case for this is, keeping the
			# code for backward compatibility)
			@formDesc.onElementSchema formElement, schemaElement  if @formDesc.onElementSchema
			formElement.name = formElement.name or formElement.key
			formElement.title = formElement.title or schemaElement.title
			formElement.description = formElement.description or schemaElement.description
			
			# Compute the ID of the input field
			formElement.id = escapeSelector(@formDesc.prefix) + "-elt-" + formElement.key  unless formElement.id
			
			# Should empty strings be included in the final value?
			# TODO: it's rather unclean to pass it through the schema.
			schemaElement._jsonform_allowEmpty = true  if formElement.allowEmpty
			
			# If the form element does not define its type, use the type of
			# the schema element.
			unless formElement.type
				if (schemaElement.type is "string") and (schemaElement.format is "color")
					formElement.type = "color"
				else if (schemaElement.type is "number" or schemaElement.type is "integer" or schemaElement.type is "string" or schemaElement.type is "any") and not schemaElement["enum"]
					formElement.type = "text"
				else if schemaElement.type is "boolean"
					formElement.type = "checkbox"
				else if schemaElement.type is "object"
					formElement.type = "fieldset"
				else unless _.isUndefined(schemaElement["enum"])
					formElement.type = "select"
				else
					formElement.type = schemaElement.type
			
			# Unless overridden in the definition of the form element (or unless
			# there's a titleMap defined), use the enumeration list defined in
			# the schema
			if not formElement.options and schemaElement["enum"]
				if formElement.titleMap
					formElement.options = _.map(schemaElement["enum"], (value) ->
						value: value
						title: formElement.titleMap[value] or value
					)
				else
					formElement.options = schemaElement["enum"]
			
			# Flag a list of checkboxes with multiple choices
			if (formElement.type is "checkboxes") and schemaElement.items
				itemsEnum = schemaElement.items["enum"]
				schemaElement.items._jsonform_checkboxes_as_array = true  if itemsEnum
				if not itemsEnum and schemaElement.items[0]
					itemsEnum = schemaElement.items[0]["enum"]
					schemaElement.items[0]._jsonform_checkboxes_as_array = true  if itemsEnum
			
			# If the form element targets an "object" in the JSON schema,
			# we need to recurse through the list of children to create an
			# input field per child property of the object in the JSON schema
			if schemaElement.type is "object"
				_.each schemaElement.properties, ((prop, propName) ->
					node.appendChild @buildFromLayout(key: formElement.key + "." + propName)
				), this
		unless formElement.type
			if formElement.parentNode
				formElement.type = "none"
			else
				formElement.type = "root"
		view = jsonform.elementTypes[formElement.type]
		throw new Error("The JSONForm contains an element whose type is unknown: \"" + formElement.type + "\"")  unless view
		if schemaElement
			
			# The form element is linked to an element in the schema.
			# Let's make sure the types are compatible.
			# In particular, the element must not be a "container"
			# (or must be an "object" or "array" container)
			throw new Error("The JSONForm contains an element that links to an element in the JSON schema (key: \"" + formElement.key + "\") and that should not based on its type (\"" + formElement.type + "\")")  if not view.inputfield and not view.array and (formElement.type isnt "selectfieldset") and (schemaElement.type isnt "object")
		else
			
			# The form element is not linked to an element in the schema.
			# This means the form element must be a "container" element,
			# and must not define an input field.
			throw new Error("The JSONForm defines an element of type \"" + formElement.type + "\" but no \"key\" property to link the input field to the JSON schema")  if view.inputfield and (formElement.type isnt "selectfieldset")
		
		# A few characters need to be escaped to use the ID as jQuery selector
		formElement.iddot = escapeSelector(formElement.id or "")
		
		# Initialize the form node from the form element and schema element
		node.formElement = formElement
		node.schemaElement = schemaElement
		node.view = view
		node.ownerTree = this
		
		# Set event handlers
		formElement.handlers = {}  unless formElement.handlers
		
		# Parse children recursively
		if node.view.array
			
			# The form element is an array. The number of items in an array
			# is by definition dynamic, up to the form user (through "Add more",
			# "Delete" commands). The positions of the items in the array may
			# also change over time (through "Move up", "Move down" commands).
			#
			# The form node stores a "template" node that serves as basis for
			# the creation of an item in the array.
			#
			# Array items may be complex forms themselves, allowing for nesting.
			#
			# The initial values set the initial number of items in the array.
			# Note a form element contains at least one item when it is rendered.
			if formElement.items
				key = formElement.items[0] or formElement.items
			else
				key = formElement.key + "[]"
			key = key: key  if _.isString(key)
			node.setChildTemplate @buildFromLayout(key)
		else if formElement.items
			
			# The form element defines children elements
			_.each formElement.items, ((item) ->
				item = key: item  if _.isString(item)
				node.appendChild @buildFromLayout(item)
			), this
		node

	
	###
	Computes the values associated with each input field in the tree based
	on previously submitted values or default values in the JSON schema.
	
	For arrays, the function actually creates and inserts additional
	nodes in the tree based on previously submitted values (also ensuring
	that the array has at least one item).
	
	The function sets the array path on all nodes.
	It should be called once in the lifetime of a form tree right after
	the tree structure has been created.
	
	@function
	###
	formTree::computeInitialValues = ->
		@root.computeInitialValues @formDesc.value

	
	###
	Renders the form tree
	
	@function
	@param {Node} domRoot The "form" element in the DOM tree that serves as
	root for the form
	###
	formTree::render = (domRoot) ->
		return  unless domRoot
		@domRoot = domRoot
		@root.render()

	
	###
	Walks down the element tree with a callback
	
	@function
	@param {Function} callback The callback to call on each element
	###
	formTree::forEachElement = (callback) ->
		f = (root) ->
			i = 0

			while i < root.children.length
				callback root.children[i]
				f root.children[i]
				i++

		f @root

	formTree::validate = (noErrorDisplay) ->
		values = jsonform.getFormValue(@domRoot)
		errors = false
		options = @formDesc
		if options.validate isnt false
			validator = false
			unless typeof options.validate is "object"
				validator = global.JSONFormValidator.createEnvironment("json-schema-draft-03")  if global.JSONFormValidator
			else
				validator = options.validate
			if validator
				v = validator.validate(values, @formDesc.schema)
				$(@domRoot).jsonFormErrors false, options
				if v.errors.length
					errors = []  unless errors
					errors = errors.concat(v.errors)
		if errors and not noErrorDisplay
			if options.displayErrors
				options.displayErrors errors, @domRoot
			else
				$(@domRoot).jsonFormErrors errors, options
		errors: errors

	formTree::submit = (evt) ->
		stopEvent = ->
			if evt
				evt.preventDefault()
				evt.stopPropagation()
			false

		values = jsonform.getFormValue(@domRoot)
		options = @formDesc
		brk = false
		@forEachElement (elt) ->
			return  if brk
			brk = not elt.view.onSubmit(evt, elt)  if elt.view.onSubmit #may be called multiple times!!

		return stopEvent()  if brk
		validated = @validate()
		return stopEvent()  if options.onSubmit and not options.onSubmit(validated.errors, values)
		return stopEvent()  if validated.errors
		return stopEvent()  if options.onSubmitValid and not options.onSubmitValid(values)
		false

	
	###
	Returns the structured object that corresponds to the form values entered
	by the use for the given form.
	
	The form must have been previously rendered through a call to jsonform.
	
	@function
	@param {Node} The <form> tag in the DOM
	@return {Object} The object that follows the data schema and matches the
	values entered by the user.
	###
	jsonform.getFormValue = (formelt) ->
		form = $(formelt).data("jsonform-tree")
		return null  unless form
		form.root.getFormValues()

	
	###
	Highlights errors reported by the JSON schema validator in the document.
	
	@function
	@param {Object} errors List of errors reported by the JSON schema validator
	@param {Object} options The JSON Form object that describes the form
	(unused for the time being, could be useful to store example values or
	specific error messages)
	###
	$.fn.jsonFormErrors = (errors, options) ->
		$(".error", this).removeClass "error"
		$(".warning", this).removeClass "warning"
		$(".jsonform-errortext", this).hide()
		return  unless errors
		i = 0

		while i < errors.length
			
			# Compute the address of the input field in the form from the URI
			# returned by the JSON schema validator.
			# These URIs typically look like:
			#  urn:uuid:cccc265e-ffdd-4e40-8c97-977f7a512853#/pictures/1/thumbnail
			# What we need from that is the path in the value object:
			#  pictures[1].thumbnail
			# ... and the jQuery-friendly class selector of the input field:
			#  .jsonform-error-pictures\[1\]---thumbnail
			key = errors[i].uri.replace(/.*#\//, "").replace(/\//g, ".").replace(/\.([0-9]+)(\.|$)/, "[$1]$2")
			errormarkerclass = ".jsonform-error-" + escapeSelector(key.replace(/\./g, "---"))
			errorType = errors[i].type or "error"
			$(errormarkerclass, this).addClass errorType
			$(errormarkerclass + " .jsonform-errortext", this).html(errors[i].message).show()
			i++

	
	###
	Generates the HTML form from the given JSON Form object and renders the form.
	
	Main entry point of the library. Defined as a jQuery function that typically
	needs to be applied to a <form> element in the document.
	
	The function handles the following properties for the JSON Form object it
	receives as parameter:
	- schema (required): The JSON Schema that describes the form to render
	- form: The options form layout description, overrides default layout
	- prefix: String to use to prefix computed IDs. Default is an empty string.
	Use this option if JSON Form is used multiple times in an application with
	schemas that have overlapping parameter names to avoid running into multiple
	IDs issues. Default value is "jsonform-[counter]".
	- transloadit: Transloadit parameters when transloadit is used
	- validate: Validates form against schema upon submission. Uses the value
	of the "validate" property as validator if it is an object.
	- displayErrors: Function to call with errors upon form submission.
	Default is to render the errors next to the input fields.
	- submitEvent: Name of the form submission event to bind to.
	Default is "submit".
	- onSubmit: Callback function to call when form is submitted
	- onSubmitValid: Callback function to call when form is submitted without
	errors.
	
	@function
	@param {Object} options The JSON Form object to use as basis for the form
	###
	$.fn.jsonForm = (options) ->
		formElt = this
		options = options or {}
		form = new formTree()
		form.initialize options
		form.render formElt.get(0)
		
		# TODO: move that to formTree.render
		formElt.append "<input type=\"hidden\" name=\"params\" value='" + escapeHTML(JSON.stringify(options.transloadit.params)) + "'>"  if options.transloadit
		
		# Keep a direct pointer to the JSON schema for form submission purpose
		formElt.data "jsonform-tree", form
		formElt.unbind (options.submitEvent or "submit") + ".jsonform"
		formElt.bind (options.submitEvent or "submit") + ".jsonform", (evt) ->
			form.submit evt

		
		# Initialize tabs sections, if any
		initializeTabs formElt
		
		# Initialize expandable sections, if any
		$(".expandable > div, .expandable > fieldset", formElt).hide()
		$(".expandable > legend", formElt).click ->
			parent = $(this).parent()
			parent.toggleClass "expanded"
			$("> div", parent).slideToggle 100

		form

	
	###
	Retrieves the structured values object generated from the values
	entered by the user and the data schema that gave birth to the form.
	
	Defined as a jQuery function that typically needs to be applied to
	a <form> element whose content has previously been generated by a
	call to "jsonForm".
	
	Unless explicitly disabled, the values are automatically validated
	against the constraints expressed in the schema.
	
	@function
	@return {Object} Structured values object that matches the user inputs
	and the data schema.
	###
	$.fn.jsonFormValue = ->
		jsonform.getFormValue this

	
	# Expose the getFormValue method to the global object
	# (other methods exposed as jQuery functions)
	global.JSONForm = global.JSONForm or util: {}
	global.JSONForm.getFormValue = jsonform.getFormValue
	global.JSONForm.fieldTemplate = jsonform.fieldTemplate
	global.JSONForm.fieldTypes = jsonform.elementTypes
	global.JSONForm.getInitialValue = getInitialValue
	global.JSONForm.util.getObjKey = jsonform.util.getObjKey
	global.JSONForm.util.setObjKey = jsonform.util.setObjKey
) (typeof exports isnt "undefined"), ((if (typeof exports isnt "undefined") then exports else window)), ((if (typeof jQuery isnt "undefined") then jQuery else fn: {})), ((if (typeof _ isnt "undefined") then _ else null)), JSON
